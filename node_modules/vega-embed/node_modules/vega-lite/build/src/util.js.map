{"version":3,"file":"util.js","sourceRoot":"","sources":["../../src/util.ts"],"names":[],"mappings":"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","sourcesContent":["import stableStringify from 'json-stable-stringify';\nimport {isArray, isNumber, isString, splitAccessPath, stringValue} from 'vega-util';\nimport {isLogicalAnd, isLogicalNot, isLogicalOr, LogicalOperand} from './logical';\n\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = {'a': 1, 'b': '2', 'c': 3};\n * pick(object, ['a', 'c']);\n * // â†’ {'a': 1, 'c': 3}\n *\n */\nexport function pick<T extends object, K extends keyof T>(obj: T, props: K[]): Pick<T, K> {\n  const copy: any = {};\n  for (const prop of props) {\n    if (obj.hasOwnProperty(prop)) {\n      copy[prop] = obj[prop];\n    }\n  }\n  return copy;\n}\n\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nexport function omit<T extends object, K extends keyof T>(obj: T, props: K[]): Omit<T,K> {\n  const copy = {...obj as any};\n  for (const prop of props) {\n    delete copy[prop];\n  }\n  return copy;\n}\n\n/**\n * Converts any object into a string representation that can be consumed by humans.\n */\nexport const stringify = stableStringify;\n\n/**\n * Converts any object into a string of limited size, or a number.\n */\nexport function hash(a: any) {\n  if (isNumber(a)) {\n    return a;\n  }\n\n  const str = isString(a) ? a : stableStringify(a);\n\n  // short strings can be used as hash directly, longer strings are hashed to reduce memory usage\n  if (str.length < 100) {\n    return str;\n  }\n\n  // from http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  let h = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    h = ((h<<5)-h)+char;\n    h = h & h; // Convert to 32bit integer\n  }\n  return h;\n}\n\nexport function contains<T>(array: T[], item: T) {\n  return array.indexOf(item) > -1;\n}\n\n/** Returns the array without the elements in item */\nexport function without<T>(array: T[], excludedItems: T[]) {\n  return array.filter(item => !contains(excludedItems, item));\n}\n\nexport function union<T>(array: T[], other: T[]) {\n  return array.concat(without(other, array));\n}\n\n/**\n * Returns true if any item returns true.\n */\nexport function some<T>(arr: T[], f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if all items return true.\n */\n export function every<T>(arr: T[], f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (!f(arr[k], k, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function flatten(arrays: any[]) {\n  return [].concat.apply([], arrays);\n}\n\n/**\n * recursively merges src into dest\n */\nexport function mergeDeep<T>(dest: T, ...src: Partial<T>[]): T {\n  for (const s of src) {\n    dest = deepMerge_(dest, s);\n  }\n  return dest;\n}\n\n// recursively merges src into dest\nfunction deepMerge_(dest: any, src: any) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (const p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || isArray(src[p]) || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = mergeDeep(isArray(src[p].constructor) ? [] : {}, src[p]);\n    } else {\n      mergeDeep(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n\nexport function unique<T>(values: T[], f: (item: T) => string | number): T[] {\n  const results: any[] = [];\n  const u = {};\n  let v: string | number;\n  for (const val of values) {\n    v = f(val);\n    if (v in u) {\n      continue;\n    }\n    u[v] = 1;\n    results.push(val);\n  }\n  return results;\n}\n\nexport interface Dict<T> {\n  [key: string]: T;\n}\n\nexport type StringSet = Dict<true>;\n\n/**\n * Returns true if the two dictionaries disagree. Applies only to defined values.\n */\nexport function differ<T>(dict: Dict<T>, other: Dict<T>) {\n  for (const key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (other[key] && dict[key] && other[key] !== dict[key]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function hasIntersection(a: StringSet, b: StringSet) {\n  for (const key in a) {\n    if (key in b) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isNumeric(num: string | number) {\n  return !isNaN(num as any);\n}\n\nexport function differArray<T>(array: T[], other: T[]) {\n  if (array.length !== other.length) {\n    return true;\n  }\n\n  array.sort();\n  other.sort();\n\n  for (let i = 0; i < array.length; i++) {\n    if (other[i] !== array[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// This is a stricter version of Object.keys but with better types. See https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208\nexport const keys = Object.keys as <T>(o: T) => (Extract<keyof T, string>)[];\n\nexport function vals<T>(x: {[key: string]: T}): T[] {\n  const _vals: T[] = [];\n  for (const k in x) {\n    if (x.hasOwnProperty(k)) {\n      _vals.push(x[k]);\n    }\n  }\n  return _vals;\n}\n\n// Using mapped type to declare a collect of flags for a string literal type S\n// https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types\nexport type Flag<S extends string> = {\n  [K in S]: 1\n};\n\nexport function flagKeys<S extends string>(f: Flag<S>): S[] {\n  return keys(f) as S[];\n}\n\nexport function duplicate<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function isBoolean(b: any): b is boolean {\n  return b === true || b === false;\n}\n\n/**\n * Convert a string into a valid variable name\n */\nexport function varName(s: string): string {\n  // Replace non-alphanumeric characters (anything besides a-zA-Z0-9_) with _\n  const alphanumericS = s.replace(/\\W/g, '_');\n\n  // Add _ if the string has leading numbers.\n  return (s.match(/^\\d+/) ? '_' : '') + alphanumericS;\n}\n\nexport function logicalExpr<T>(op: LogicalOperand<T>, cb: Function): string {\n  if (isLogicalNot(op)) {\n    return '!(' + logicalExpr(op.not, cb) + ')';\n  } else if (isLogicalAnd(op)) {\n    return '(' + op.and.map((and: LogicalOperand<T>) => logicalExpr(and, cb)).join(') && (') + ')';\n  } else if (isLogicalOr(op)) {\n    return '(' + op.or.map((or: LogicalOperand<T>) => logicalExpr(or, cb)).join(') || (') + ')';\n  } else {\n    return cb(op);\n  }\n}\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Delete nested property of an object, and delete the ancestors of the property if they become empty.\n */\nexport function deleteNestedProperty(obj: any, orderedProps: string[]) {\n  if (orderedProps.length === 0) {\n    return true;\n  }\n  const prop = orderedProps.shift();\n  if (deleteNestedProperty(obj[prop], orderedProps)) {\n    delete obj[prop];\n  }\n  return Object.keys(obj).length === 0;\n}\n\nexport function titlecase(s: string) {\n  return s.charAt(0).toUpperCase() + s.substr(1);\n}\n\n/**\n * Converts a path to an access path with datum.\n * @param path The field name.\n * @param datum The string to use for `datum`.\n */\nexport function accessPathWithDatum(path: string, datum='datum') {\n  const pieces = splitAccessPath(path);\n  const prefixes = [];\n  for (let i = 1; i <= pieces.length; i++) {\n    const prefix = `[${pieces.slice(0,i).map(stringValue).join('][')}]`;\n    prefixes.push(`${datum}${prefix}`);\n  }\n  return prefixes.join(' && ');\n}\n\n/**\n * Return access with datum to the falttened field.\n * @param path The field name.\n * @param datum The string to use for `datum`.\n */\nexport function flatAccessWithDatum(path: string, datum='datum') {\n  return `${datum}[${stringValue(splitAccessPath(path).join('.'))}]`;\n}\n\n/**\n * Replaces path accesses with access to non-nested field.\n * For example, `foo[\"bar\"].baz` becomes `foo\\\\.bar\\\\.baz`.\n */\nexport function replacePathInField(path: string) {\n  return `${splitAccessPath(path).map(p => p.replace('.', '\\\\.')).join('\\\\.')}`;\n}\n\n/**\n * Remove path accesses with access from field.\n * For example, `foo[\"bar\"].baz` becomes `foo.bar.baz`.\n */\nexport function removePathFromField(path: string) {\n  return `${splitAccessPath(path).join('.')}`;\n}\n\n/**\n * Count the depth of the path. Returns 1 for fields that are not nested.\n */\nexport function accessPathDepth(path: string) {\n  if (!path) {\n    return 0;\n  }\n  return splitAccessPath(path).length;\n}\n"]}