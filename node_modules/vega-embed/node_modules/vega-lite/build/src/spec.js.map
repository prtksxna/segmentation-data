{"version":3,"file":"spec.js","sourceRoot":"","sources":["../../src/spec.ts"],"names":[],"mappings":"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","sourcesContent":["import {isObject} from 'vega-util';\nimport {COLUMN, ROW, X, X2, Y, Y2} from './channel';\nimport * as compositeMark from './compositemark';\nimport {Config} from './config';\nimport {Data} from './data';\nimport * as vlEncoding from './encoding';\nimport {channelHasField, Encoding, EncodingWithFacet, isRanged} from './encoding';\nimport {FacetMapping} from './facet';\nimport {Field, FieldDef, RepeatRef} from './fielddef';\nimport * as log from './log';\nimport {AnyMark, AreaConfig, isMarkDef, isPathMark, isPrimitiveMark, LineConfig, Mark, MarkConfig, MarkDef} from './mark';\nimport {Projection} from './projection';\nimport {Repeat} from './repeat';\nimport {Resolve} from './resolve';\nimport {SelectionDef} from './selection';\nimport {stack} from './stack';\nimport {TitleParams} from './title';\nimport {ConcatLayout, GenericCompositionLayout, TopLevelProperties} from './toplevelprops';\nimport {Transform} from './transform';\nimport {Dict, duplicate, hash, keys, omit, pick, vals} from './util';\n\n\nexport type TopLevel<S extends BaseSpec> = S & TopLevelProperties & {\n  /**\n   * URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.\n   * @format uri\n   */\n  $schema?: string;\n\n  /**\n   * Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.\n   */\n  config?: Config;\n};\n\nexport type BaseSpec = Partial<DataMixins> & {\n  /**\n   * Title for the plot.\n   */\n  title?: string | TitleParams;\n\n  /**\n   * Name of the visualization for later reference.\n   */\n  name?: string;\n\n  /**\n   * Description of this mark for commenting purpose.\n   */\n  description?: string;\n\n  /**\n   * An object describing the data source\n   */\n  data?: Data;\n\n  /**\n   * An array of data transformations such as filter and new field calculation.\n   */\n  transform?: Transform[];\n};\n\nexport type DataMixins = {\n  /**\n   * An object describing the data source\n   */\n  data: Data;\n};\n\n\n// TODO(https://github.com/vega/vega-lite/issues/2503): Make this generic so we can support some form of top-down sizing.\nexport interface LayoutSizeMixins {\n  /**\n   * The width of a visualization.\n   *\n   * __Default value:__ This will be determined by the following rules:\n   *\n   * - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the width will be the value of [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - For x-axis with a band or point scale: if [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](https://vega.github.io/vega-lite/docs/scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](https://vega.github.io/vega-lite/docs/size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n   *\n   * __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view.\n   *\n   * __See also:__ The documentation for [width and height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.\n   */\n  width?: number;\n\n  /**\n   * The height of a visualization.\n   *\n   * __Default value:__\n   * - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the height will be the value of [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - For y-axis with a band or point scale: if [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](https://vega.github.io/vega-lite/docs/scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n   *\n   * __Note__: For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view.\n   *\n   * __See also:__ The documentation for [width and height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.\n   */\n  height?: number;\n}\n\nexport interface GenericUnitSpec<E extends Encoding<any>, M> extends BaseSpec, LayoutSizeMixins {\n\n  /**\n   * A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n   */\n  mark: M;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding?: E;\n\n\n  /**\n   * An object defining properties of geographic projection, which will be applied to `shape` path for `\"geoshape\"` marks\n   * and to `latitude` and `\"longitude\"` channels for other marks.\n   */\n  projection?: Projection;\n\n  /**\n   * A key-value mapping between selection names and definitions.\n   */\n  selection?: {[name: string]: SelectionDef};\n}\n\nexport type NormalizedUnitSpec = GenericUnitSpec<Encoding<string | RepeatRef>, Mark | MarkDef>;\n\n/**\n * Unit spec that can have a composite mark.\n */\nexport type CompositeUnitSpec = GenericUnitSpec<Encoding<string | RepeatRef>, AnyMark>;\n\n/**\n * Unit spec that can have a composite mark and row or column channels.\n */\nexport type FacetedCompositeUnitSpec = GenericUnitSpec<EncodingWithFacet<string | RepeatRef>, AnyMark>;\n\nexport interface GenericLayerSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec, LayoutSizeMixins {\n  /**\n   * Layer or single view specifications to be layered.\n   *\n   * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed.\n   */\n  layer: (GenericLayerSpec<U> | U)[];\n\n  /**\n   * Scale, axis, and legend resolutions for layers.\n   */\n  resolve?: Resolve;\n}\n\n/**\n * Layer Spec with encoding and projection\n */\nexport interface ExtendedLayerSpec extends GenericLayerSpec<CompositeUnitSpec> {\n  /**\n   * A shared key-value mapping between encoding channels and definition of fields in the underlying layers.\n   */\n  encoding?: Encoding<string | RepeatRef>;\n\n\n  /**\n   * An object defining properties of the geographic projection shared by underlying layers.\n   */\n  projection?: Projection;\n}\n\nexport type NormalizedLayerSpec = GenericLayerSpec<NormalizedUnitSpec>;\n\n\nexport interface GenericFacetSpec<\n  U extends GenericUnitSpec<any, any>,\n  L extends GenericLayerSpec<any>\n  > extends BaseSpec, GenericCompositionLayout {\n  /**\n   * An object that describes mappings between `row` and `column` channels and their field definitions.\n   */\n  facet: FacetMapping<string | RepeatRef>;\n\n  /**\n   * A specification of the view that gets faceted.\n   */\n  spec: L | U;\n  // TODO: replace this with GenericSpec<U> once we support all cases;\n\n  /**\n   * Scale, axis, and legend resolutions for facets.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedFacetSpec = GenericFacetSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport interface GenericRepeatSpec<\n  U extends GenericUnitSpec<any, any>,\n  L extends GenericLayerSpec<any>\n> extends BaseSpec, GenericCompositionLayout {\n  /**\n   * An object that describes what fields should be repeated into views that are laid out as a `row` or `column`.\n   */\n  repeat: Repeat;\n\n  spec: GenericSpec<U, L>;\n\n  /**\n   * Scale and legend resolutions for repeated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedRepeatSpec = GenericRepeatSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport interface GenericVConcatSpec<\n  U extends GenericUnitSpec<any, any>,\n  L extends GenericLayerSpec<any>\n> extends BaseSpec, ConcatLayout {\n  /**\n   * A list of views that should be concatenated and put into a column.\n   */\n  vconcat: (GenericSpec<U, L>)[];\n\n  /**\n   * Scale, axis, and legend resolutions for vertically concatenated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport interface GenericHConcatSpec<\n  U extends GenericUnitSpec<any, any>,\n  L extends GenericLayerSpec<any>\n> extends BaseSpec, ConcatLayout {\n  /**\n   * A list of views that should be concatenated and put into a row.\n   */\n  hconcat: (GenericSpec<U, L>)[];\n\n  /**\n   * Scale, axis, and legend resolutions for horizontally concatenated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedConcatSpec =\n  GenericVConcatSpec<NormalizedUnitSpec, NormalizedLayerSpec> | GenericHConcatSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport type GenericSpec<\n  U extends GenericUnitSpec<any, any>,\n  L extends GenericLayerSpec<any>\n> = U | L | GenericFacetSpec<U, L> | GenericRepeatSpec<U, L> |\n  GenericVConcatSpec<U, L> |GenericHConcatSpec<U, L>;\n\nexport type NormalizedSpec = GenericSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport type TopLevelFacetedUnitSpec = TopLevel<FacetedCompositeUnitSpec> & DataMixins;\nexport type TopLevelFacetSpec = TopLevel<GenericFacetSpec<CompositeUnitSpec, ExtendedLayerSpec>> & DataMixins;\n\nexport type TopLevelSpec = TopLevelFacetedUnitSpec | TopLevelFacetSpec | TopLevel<ExtendedLayerSpec> |\nTopLevel<GenericRepeatSpec<CompositeUnitSpec, ExtendedLayerSpec>> | TopLevel<GenericVConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>> | TopLevel<GenericHConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>>;\n\n/* Custom type guards */\n\n\nexport function isFacetSpec(spec: BaseSpec): spec is GenericFacetSpec<any, any> {\n  return spec['facet'] !== undefined;\n}\n\nexport function isUnitSpec(spec: BaseSpec): spec is FacetedCompositeUnitSpec | NormalizedUnitSpec {\n  return !!spec['mark'];\n}\n\nexport function isLayerSpec(spec: BaseSpec): spec is GenericLayerSpec<any> {\n  return spec['layer'] !== undefined;\n}\n\nexport function isRepeatSpec(spec: BaseSpec): spec is GenericRepeatSpec<any, any> {\n  return spec['repeat'] !== undefined;\n}\n\nexport function isConcatSpec(spec: BaseSpec):\n  spec is GenericVConcatSpec<any, any> |\n    GenericHConcatSpec<any, any> {\n  return isVConcatSpec(spec) || isHConcatSpec(spec);\n}\n\nexport function isVConcatSpec(spec: BaseSpec): spec is GenericVConcatSpec<any, any> {\n  return spec['vconcat'] !== undefined;\n}\n\nexport function isHConcatSpec(spec: BaseSpec): spec is GenericHConcatSpec<any, any> {\n  return spec['hconcat'] !== undefined;\n}\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\n// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize\nexport function normalize(spec: TopLevelSpec | GenericSpec<CompositeUnitSpec, ExtendedLayerSpec> | FacetedCompositeUnitSpec, config: Config): NormalizedSpec {\n  if (isFacetSpec(spec)) {\n    return normalizeFacet(spec, config);\n  }\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec, config);\n  }\n  if (isRepeatSpec(spec)) {\n    return normalizeRepeat(spec, config);\n  }\n  if (isVConcatSpec(spec)) {\n    return normalizeVConcat(spec, config);\n  }\n  if (isHConcatSpec(spec)) {\n    return normalizeHConcat(spec, config);\n  }\n  if (isUnitSpec(spec)) {\n    const hasRow = channelHasField(spec.encoding, ROW);\n    const hasColumn = channelHasField(spec.encoding, COLUMN);\n\n    if (hasRow || hasColumn) {\n      return normalizeFacetedUnit(spec, config);\n    }\n    return normalizeNonFacetUnit(spec, config);\n  }\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nfunction normalizeFacet(spec: GenericFacetSpec<CompositeUnitSpec, ExtendedLayerSpec>, config: Config): NormalizedFacetSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n    spec: normalize(subspec, config) as any\n  };\n}\n\nfunction mergeEncoding(opt: {parentEncoding: Encoding<any>, encoding: Encoding<any>}): Encoding<any> {\n  const {parentEncoding, encoding} = opt;\n  if (parentEncoding && encoding) {\n    const overriden = keys(parentEncoding).reduce((o, key) => {\n      if (encoding[key]) {\n        o.push(key);\n      }\n      return o;\n    }, []);\n\n    if (overriden.length > 0) {\n      log.warn(log.message.encodingOverridden(overriden));\n    }\n  }\n\n  const merged = {\n    ...(parentEncoding || {}),\n    ...(encoding || {})\n  };\n  return keys(merged).length > 0 ? merged : undefined;\n}\n\nfunction mergeProjection(opt: {parentProjection: Projection, projection: Projection}) {\n  const {parentProjection, projection} = opt;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({parentProjection, projection}));\n  }\n  return projection || parentProjection;\n}\n\nfunction normalizeLayer(\n  spec: ExtendedLayerSpec,\n  config: Config,\n  parentEncoding?: Encoding<string | RepeatRef>,\n  parentProjection?: Projection\n): NormalizedLayerSpec {\n  const {layer, encoding, projection, ...rest} = spec;\n  const mergedEncoding = mergeEncoding({parentEncoding, encoding});\n  const mergedProjection = mergeProjection({parentProjection, projection});\n  return {\n    ...rest,\n    layer: layer.map((subspec) => {\n      if (isLayerSpec(subspec)) {\n        return normalizeLayer(subspec, config, mergedEncoding, mergedProjection);\n      }\n      return normalizeNonFacetUnit(subspec, config, mergedEncoding, mergedProjection);\n    })\n  };\n}\n\nfunction normalizeRepeat(spec: GenericRepeatSpec<CompositeUnitSpec, ExtendedLayerSpec>, config: Config): NormalizedRepeatSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    spec: normalize(subspec, config)\n  };\n}\n\nfunction normalizeVConcat(spec: GenericVConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>, config: Config): NormalizedConcatSpec {\n  const {vconcat: vconcat, ...rest} = spec;\n  return {\n    ...rest,\n    vconcat: vconcat.map((subspec) => normalize(subspec, config))\n  };\n}\n\nfunction normalizeHConcat(spec: GenericHConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>, config: Config): NormalizedConcatSpec {\n  const {hconcat: hconcat, ...rest} = spec;\n  return {\n    ...rest,\n    hconcat: hconcat.map((subspec) => normalize(subspec, config))\n  };\n}\n\nfunction normalizeFacetedUnit(spec: FacetedCompositeUnitSpec, config: Config): NormalizedFacetSpec {\n  // New encoding in the inside spec should not contain row / column\n  // as row/column should be moved to facet\n  const {row: row, column: column, ...encoding} = spec.encoding;\n\n  // Mark and encoding should be moved into the inner spec\n  const {mark, width, projection, height, selection, encoding: _, ...outerSpec} = spec;\n\n  return {\n    ...outerSpec,\n    facet: {\n      ...(row ? {row} : {}),\n      ...(column ? {column}: {}),\n    },\n    spec: normalizeNonFacetUnit({\n      ...(projection ? {projection} : {}),\n      mark,\n      ...(width ? {width} : {}),\n      ...(height ? {height} : {}),\n      encoding,\n      ...(selection ? {selection} : {})\n    }, config)\n  };\n}\n\nfunction isNonFacetUnitSpecWithPrimitiveMark(spec: GenericUnitSpec<Encoding<Field>, AnyMark>):\n  spec is GenericUnitSpec<Encoding<Field>, Mark> {\n    return isPrimitiveMark(spec.mark);\n}\n\nfunction getPointOverlay(markDef: MarkDef, markConfig: LineConfig, encoding: Encoding<Field>): MarkConfig {\n  if (markDef.point === 'transparent') {\n    return {opacity: 0};\n  } else if (markDef.point) { // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) { // false or null\n    return null;\n  } else { // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return null;\n  }\n}\n\nfunction getLineOverlay(markDef: MarkDef, markConfig: AreaConfig): MarkConfig {\n  if (markDef.line) { // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) { // false or null\n    return null;\n  } else { // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return null;\n  }\n}\n\nfunction normalizeNonFacetUnit(\n  spec: GenericUnitSpec<Encoding<Field>, AnyMark>, config: Config,\n  parentEncoding?: Encoding<string | RepeatRef>, parentProjection?: Projection\n): NormalizedUnitSpec | NormalizedLayerSpec {\n  const {encoding, projection} = spec;\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n\n\n  // merge parent encoding / projection first\n  if (parentEncoding || parentProjection) {\n    const mergedProjection = mergeProjection({parentProjection, projection});\n    const mergedEncoding = mergeEncoding({parentEncoding, encoding});\n    return normalizeNonFacetUnit({\n      ...spec,\n      ...(mergedProjection ? {projection: mergedProjection} : {}),\n      ...(mergedEncoding ? {encoding: mergedEncoding} : {}),\n    }, config);\n  }\n\n  if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {\n    // TODO: thoroughly test\n    if (isRanged(encoding)) {\n      return normalizeRangedUnit(spec);\n    }\n\n    if (mark === 'line' && (encoding.x2 || encoding.y2)) {\n      log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n\n      return normalizeNonFacetUnit({\n        mark: 'rule',\n        ...spec\n      }, config, parentEncoding, parentProjection);\n    }\n\n    if (isPathMark(mark)) {\n      return normalizePathOverlay(spec, config);\n    }\n\n    return spec; // Nothing to normalize\n  } else {\n    return compositeMark.normalize(spec, config);\n  }\n}\n\nfunction normalizeRangedUnit(spec: NormalizedUnitSpec) {\n  const hasX = channelHasField(spec.encoding, X);\n  const hasY = channelHasField(spec.encoding, Y);\n  const hasX2 = channelHasField(spec.encoding, X2);\n  const hasY2 = channelHasField(spec.encoding, Y2);\n  if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n    const normalizedSpec = duplicate(spec);\n    if (hasX2 && !hasX) {\n      normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n      delete normalizedSpec.encoding.x2;\n    }\n    if (hasY2 && !hasY) {\n      normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n      delete normalizedSpec.encoding.y2;\n    }\n\n    return normalizedSpec;\n  }\n  return spec;\n}\n\nfunction dropLineAndPoint(markDef: MarkDef): MarkDef | Mark {\n  const {point: _point, line: _line, ...mark} = markDef;\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction normalizePathOverlay(spec: NormalizedUnitSpec, config: Config = {}): NormalizedLayerSpec | NormalizedUnitSpec {\n\n  // _ is used to denote a dropped property of the unit spec\n  // which should not be carried over to the layer spec\n  const {selection, projection, encoding, mark, ...outerSpec} = spec;\n  const markDef = isMarkDef(mark) ? mark : {type: mark};\n\n  const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n  const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n\n  if (!pointOverlay && !lineOverlay) {\n    return {\n      ...spec,\n      // Do not include point / line overlay in the normalize spec\n      mark: dropLineAndPoint(markDef)\n    };\n  }\n\n  const layer: NormalizedUnitSpec[] = [{\n    ...(selection ? {selection} : {}),\n    // Do not include point / line overlay in the normalize spec\n    mark: dropLineAndPoint({\n      ...markDef,\n      // make area mark translucent by default\n      // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n      ...(markDef.type === 'area' ? {opacity: 0.7} : {}),\n    }),\n    // drop shape from encoding as this might be used to trigger point overlay\n    encoding: omit(encoding, ['shape'])\n  }];\n\n  // FIXME: determine rules for applying selections.\n\n  // Need to copy stack config to overlayed layer\n  const stackProps = stack(markDef, encoding, config ? config.stack : undefined);\n\n  let overlayEncoding = encoding;\n  if (stackProps) {\n    const {fieldChannel: stackFieldChannel, offset} = stackProps;\n    overlayEncoding = {\n      ...encoding,\n      [stackFieldChannel]: {\n        ...encoding[stackFieldChannel],\n        ...(offset ? {stack: offset} : {})\n      }\n    };\n  }\n\n  if (lineOverlay) {\n    layer.push({\n      ...(projection ? {projection} : {}),\n      mark: {\n        type: 'line',\n        ...pick(markDef, ['clip', 'interpolate']),\n        ...lineOverlay\n      },\n      encoding: overlayEncoding\n    });\n  }\n  if (pointOverlay) {\n    layer.push({\n      ...(projection ? {projection} : {}),\n      mark: {\n        type: 'point',\n        opacity: 1,\n        filled: true,\n        ...pick(markDef, ['clip']),\n        ...pointOverlay\n      },\n      encoding: overlayEncoding\n    });\n  }\n\n  return {\n    ...outerSpec,\n    layer\n  };\n}\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\n/* Accumulate non-duplicate fieldDefs in a dictionary */\nfunction accumulate(dict: any, defs: FieldDef<Field>[]): any {\n  defs.forEach(function(fieldDef) {\n    // Consider only pure fieldDef properties (ignoring scale, axis, legend)\n    const pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce((f, key) => {\n      if (fieldDef[key] !== undefined) {\n        f[key] = fieldDef[key];\n      }\n      return f;\n    }, {});\n    const key = hash(pureFieldDef);\n    dict[key] = dict[key] || fieldDef;\n  });\n  return dict;\n}\n\n/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */\nfunction fieldDefIndex<T>(spec: GenericSpec<any, any>, dict: Dict<FieldDef<T>> = {}): Dict<FieldDef<T>> {\n  // FIXME(https://github.com/vega/vega-lite/issues/2207): Support fieldDefIndex for repeat\n  if (isLayerSpec(spec)) {\n    spec.layer.forEach(layer => {\n      if (isUnitSpec(layer)) {\n        accumulate(dict, vlEncoding.fieldDefs(layer.encoding));\n      } else {\n        fieldDefIndex(layer, dict);\n      }\n    });\n  } else if (isFacetSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.facet));\n    fieldDefIndex(spec.spec, dict);\n  } else if (isRepeatSpec(spec)) {\n    fieldDefIndex(spec.spec, dict);\n  } else if (isConcatSpec(spec)) {\n    const childSpec = isVConcatSpec(spec) ? spec.vconcat : spec.hconcat;\n    childSpec.forEach(child => fieldDefIndex(child, dict));\n  } else { // Unit Spec\n    accumulate(dict, vlEncoding.fieldDefs(spec.encoding));\n  }\n  return dict;\n}\n\n/* Returns all non-duplicate fieldDefs in a spec in a flat array */\nexport function fieldDefs(spec: GenericSpec<any, any>): FieldDef<any>[] {\n  return vals(fieldDefIndex(spec));\n}\n\nexport function isStacked(spec: TopLevel<FacetedCompositeUnitSpec>, config?: Config): boolean {\n  config = config || spec.config;\n  if (isPrimitiveMark(spec.mark)) {\n    return stack(spec.mark, spec.encoding,\n            config ? config.stack : undefined\n          ) !== null;\n  }\n  return false;\n}\n"]}