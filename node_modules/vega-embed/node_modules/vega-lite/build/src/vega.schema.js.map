{"version":3,"file":"vega.schema.js","sourceRoot":"","sources":["../../src/vega.schema.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,OAAO,EAAC,MAAM,WAAW,CAAC;AAMlC,OAAO,EAAO,QAAQ,EAAC,MAAM,QAAQ,CAAC;AAgDtC,MAAM,wBAAwB,CAAM;IAClC,OAAO,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;AACvB,CAAC;AAmCD,MAAM,wBAAwB,KAAc;IAC1C,OAAO,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;AACzB,CAAC;AA6HD,MAAM,iCAAiC,MAAgB;IACrD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QACpB,OAAO,QAAQ,IAAI,MAAM,IAAI,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,CAAC;KAClD;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,MAAM,gCAAgC,MAAgB;IACpD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QACpB,OAAO,QAAQ,IAAI,MAAM,IAAI,MAAM,IAAI,MAAM,CAAC;KAC/C;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,MAAM,0BAA0B,MAAgB;IAC9C,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QACnB,OAAO,OAAO,IAAI,MAAM,IAAI,MAAM,IAAI,MAAM,CAAC;KAC/C;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,MAAM,4BAA4B,MAAgB;IAChD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QACpB,OAAO,QAAQ,IAAI,MAAM,CAAC;KAC3B;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AA+9BD,IAAM,oBAAoB,GAA6B;IACrD,OAAO,EAAE,CAAC;IACV,IAAI,EAAE,CAAC;IACP,WAAW,EAAE,CAAC;IACd,MAAM,EAAE,CAAC;IACT,SAAS,EAAE,CAAC;IACZ,WAAW,EAAE,CAAC;IACd,aAAa,EAAE,CAAC;IAChB,UAAU,EAAE,CAAC;IACb,gBAAgB,EAAE,CAAC;IACnB,UAAU,EAAE,CAAC;IACb,gBAAgB,EAAE,CAAC;IACnB,IAAI,EAAE,CAAC;IACP,KAAK,EAAE,CAAC;IACR,WAAW,EAAE,CAAC;IACd,OAAO,EAAE,CAAC;IACV,MAAM,EAAE,CAAC;IACT,KAAK,EAAE,CAAC;IACR,QAAQ,EAAE,CAAC;IACX,IAAI,EAAE,CAAC;IACP,GAAG,EAAE,CAAC;IACN,EAAE,EAAE,CAAC;IACL,EAAE,EAAE,CAAC;IACL,QAAQ,EAAE,CAAC;IACX,KAAK,EAAE,CAAC;IACR,MAAM,EAAE,CAAC;IACT,KAAK,EAAE,CAAC;IACR,KAAK,EAAE,CAAC;IACR,IAAI,EAAE,CAAC;IACP,QAAQ,EAAE,CAAC;IACX,UAAU,EAAE,CAAC;IACb,SAAS,EAAE,CAAC;IACZ,MAAM,EAAE,CAAC;IACT,IAAI,EAAE,CAAC;IACP,OAAO,EAAE,CAAC;IACV,YAAY,EAAE,CAAC;CAUhB,CAAC;AAEF,MAAM,CAAC,IAAM,eAAe,GAAG,QAAQ,CAAC,oBAAoB,CAAC,CAAC","sourcesContent":["import {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {BaseBin} from './bin';\nimport {NiceTime, ScaleType} from './scale';\nimport {SortOrder} from './sort';\nimport {StackOffset} from './stack';\nimport {WindowOnlyOp} from './transform';\nimport {Flag, flagKeys} from './util';\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: {\n    type?: string;\n    parse?: string | object;\n    property?: string;\n    feature?: string;\n    mesh?: string;\n  };\n  url?: string;\n  transform?: VgTransform[];\n}\n\n\nexport interface VgParentRef {\n  parent: string;\n}\n\nexport type VgFieldRef = string | VgParentRef | VgParentRef[];\n\nexport type VgSortField = true | {\n  field?: VgFieldRef,\n  op: AggregateOp,\n  order?: SortOrder\n};\n\n/**\n * Unioned domains can only be sorted by count aggregate.\n */\nexport type VgUnionSortField = true | {\n  op: 'count'\n  order?: SortOrder\n};\n\nexport interface VgDataRef {\n  data: string;\n  field: VgFieldRef;\n  sort?: VgSortField;\n}\n\nexport interface VgSignalRef {\n  signal: string;\n}\n\nexport function isVgSignalRef(o: any): o is VgSignalRef {\n  return !!o['signal'];\n}\n\nexport type VgEventStream = any;\n\n// TODO: add type of value (Make it VgValueRef<T> {value?:T ...})\nexport interface VgValueRef {\n  value?: number | string | boolean;\n  field?: string | {\n    datum?: string,\n    group?: string,\n    parent?: string\n  };\n  signal?: string;\n  scale?: string; // TODO: object\n  mult?: number;\n  offset?: number | VgValueRef;\n  band?: boolean | number | VgValueRef;\n}\n\n// TODO: add vg prefix\nexport interface DataRefUnionDomain {\n  fields: (any[] | VgDataRef | VgSignalRef)[];\n  sort?: VgUnionSortField;\n}\n\nexport interface VgFieldRefUnionDomain {\n  data: string;\n  fields: VgFieldRef[];\n  sort?: VgUnionSortField;\n}\n\nexport type VgScheme = {scheme: string, extent?: number[], count?: number};\nexport type VgRange = string | VgDataRef | (number|string|VgDataRef|VgSignalRef)[] | VgScheme | VgRangeStep;\n\nexport type VgRangeStep = {step: number | VgSignalRef};\nexport function isVgRangeStep(range: VgRange): range is VgRangeStep {\n  return !!range['step'];\n}\n\n// Domains that are not a union of domains\nexport type VgNonUnionDomain = any[] | VgDataRef | VgSignalRef;\nexport type VgDomain = VgNonUnionDomain | DataRefUnionDomain | VgFieldRefUnionDomain;\n\nexport type VgMarkGroup = any;\n\nexport type VgProjectionType = 'albers' | 'albersUsa' | 'azimuthalEqualArea' | 'azimuthalEquidistant' | 'conicConformal' | 'conicEqualArea' | 'conicEquidistant' | 'equirectangular' | 'gnomonic' | 'mercator' | 'orthographic' | 'stereographic' | 'transverseMercator';\n\n\nexport type VgProjection = {\n  /*\n   * The name of the projection.\n   */\n  name: string;\n  /*\n   * The type of the projection.\n   */\n  type?: VgProjectionType;\n  /*\n   * The clip angle of the projection.\n   */\n  clipAngle?: number;\n  /*\n   * Sets the projection’s viewport clip extent to the specified bounds in pixels\n   */\n  clipExtent?: number[][];\n  /*\n   * Sets the projection’s scale factor to the specified value\n   */\n  scale?: number;\n  /*\n   * The translation of the projection.\n   */\n  translate?: number[];\n  /*\n   * The center of the projection.\n   */\n  center?: number[];\n  /**\n   * The rotation of the projection.\n   */\n  rotate?: number[];\n  /*\n   * The desired precision of the projection.\n   */\n  precision?: String;\n  /*\n   * GeoJSON data to which the projection should attempt to automatically fit the translate and scale parameters..\n   */\n  fit?: VgSignalRef | Object | any[];\n  /*\n   * Used in conjunction with fit, provides the pixel area to which the projection should be automatically fit.\n   */\n  extent?: VgSignalRef | number[][];\n  /*\n   * Used in conjunction with fit, provides the width and height in pixels of the area to which the projection should be automatically fit.\n   */\n  size?: VgSignalRef | (number | VgSignalRef)[];\n\n  /* The following properties are all supported for specific types of projections. Consult the d3-geo-projection library for more information: https://github.com/d3/d3-geo-projection */\n  coefficient?: number;\n  distance?: number;\n  fraction?: number;\n  lobes?: number;\n  parallel?: number;\n  radius?: number;\n  ratio?: number;\n  spacing?: number;\n  tilt?: number;\n};\n\nexport interface VgScale {\n  name: string;\n  type: ScaleType;\n  domain: VgDomain;\n  domainRaw?: VgSignalRef;\n  range: VgRange;\n\n  clamp?: boolean;\n  base?: number;\n  exponent?: number;\n  interpolate?: ScaleInterpolate | ScaleInterpolateParams;\n  nice?: boolean | number | NiceTime | {interval: string, step: number};\n  padding?: number;\n  paddingInner?: number;\n  paddingOuter?: number;\n  reverse?: boolean;\n  round?: boolean;\n  zero?: boolean;\n}\n\nexport type ScaleInterpolate = 'rgb'| 'lab' | 'hcl' | 'hsl' | 'hsl-long' | 'hcl-long' | 'cubehelix' | 'cubehelix-long';\n\nexport interface ScaleInterpolateParams {\n  type: 'rgb' | 'cubehelix' | 'cubehelix-long';\n  gamma?: number;\n}\n\nexport type VgLayoutAlign = 'none' | 'each' | 'all';\n\nexport type RowCol<T> = {\n  row?: T,\n  column?: T\n};\n\nexport interface VgLayout {\n  center?: boolean | RowCol<boolean>;\n  padding?: number | RowCol<number>;\n  headerBand?: number | RowCol<number>;\n  footerBand?: number | RowCol<number>;\n  offset?: number | {\n    rowHeader?: number,\n    rowFooter?: number,\n    rowTitle?: number,\n    columnHeader?: number,\n    columnFooter?: number,\n    columnTitle?: number\n  };\n  bounds?: 'full' | 'flush';\n  columns?: number | {signal: string};\n  align?: VgLayoutAlign | RowCol<VgLayoutAlign>;\n}\n\nexport function isDataRefUnionedDomain(domain: VgDomain): domain is DataRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n  return false;\n}\n\nexport function isFieldRefUnionDomain(domain: VgDomain): domain is VgFieldRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: VgDomain): domain is VgDataRef {\n  if (!isArray(domain)) {\n     return 'field' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isSignalRefDomain(domain: VgDomain): domain is VgSignalRef {\n  if (!isArray(domain)) {\n    return 'signal' in domain;\n  }\n  return false;\n}\n\nexport interface VgEventHandler {\n  events: string[] | VgSignalRef;\n  update?: string;\n  encode?: string;\n  force?: boolean;\n  between?: any[];\n}\n\nexport interface VgSignal {\n  name: string;\n  bind?: string;\n  description?: string;\n  on?: VgEventHandler[];\n  update?: string;\n  react?: boolean;\n  value?: string | number | boolean | {} | VgSignalRef;\n  // only for nested signals\n  push?: string;\n}\n\nexport type VgEncodeChannel = 'x'|'x2'|'xc'|'width'|'y'|'y2'|'yc'|'height'|'opacity'|'fill'|'fillOpacity'|'stroke'|'strokeWidth'|'strokeCap'|'strokeOpacity'|'strokeDash'|'strokeDashOffset'|'strokeMiterLimit'|'strokeJoin'|'cursor'|'clip'|'size'|'shape'|'path'|'innerRadius'|'outerRadius'|'startAngle'|'endAngle'|'interpolate'|'tension'|'orient'|'url'|'align'|'baseline'|'text'|'dir'|'ellipsis'|'limit'|'dx'|'dy'|'radius'|'theta'|'angle'|'font'|'fontSize'|'fontWeight'|'fontStyle'|'tooltip'|'href'|'cursor'|'defined'|'cornerRadius';\nexport type VgEncodeEntry = {\n  [k in VgEncodeChannel]?: VgValueRef | (VgValueRef & {test?: string})[];\n};\n\n\n// TODO: make export interface VgEncodeEntry {\n//   x?: VgValueRef<number>\n//   y?: VgValueRef<number>\n//  ...\n//   color?: VgValueRef<string>\n//  ...\n// }\n\nexport type AxisOrient = 'top' | 'right' | 'left' | 'bottom';\n\nexport interface VgAxis {\n  scale: string;\n  domain?: boolean;\n  format?: string;\n  grid?: boolean;\n  gridScale?: string;\n\n  labels?: boolean;\n\n  labelBound?: boolean | number;\n  labelFlush?: boolean | number;\n  labelPadding?: number;\n  labelOverlap?: boolean | 'parity' | 'greedy';\n  maxExtent?: number;\n  minExtent?: number;\n  offset?: number;\n  orient?: AxisOrient;\n  position?: number;\n\n  ticks?: boolean;\n  tickCount?: number;\n  tickSize?: number;\n\n  title?: string;\n  titlePadding?: number;\n\n  values?: any[] | VgSignalRef;\n  zindex?: number;\n\n  encode?: VgAxisEncode;\n}\n\nexport type LegendType = 'symbol' | 'gradient';\n\nexport interface VgLegend {\n  fill?: string;\n  stroke?: string;\n  size?: string;\n  shape?: string;\n  opacity?: string;\n\n  entryPadding?: number;\n  format?: string;\n\n  offset?: number;\n  orient?: LegendOrient;\n  padding?: number;\n\n  tickCount?: number;\n  title?: string;\n  type?: LegendType;\n  values?: any[] | VgSignalRef;\n  zindex?: number;\n\n  encode?: VgLegendEncode;\n}\n\nexport interface VgBinTransform extends BaseBin {\n  type: 'bin';\n  extent?: number[] | {signal: string};\n  field: string;\n  as: string[];\n  signal?: string;\n}\n\nexport interface VgExtentTransform {\n  type: 'extent';\n  field: string;\n  signal: string;\n}\n\nexport interface VgFormulaTransform {\n  type: 'formula';\n  as: string;\n  expr: string;\n}\n\nexport interface VgFilterTransform {\n  type: 'filter';\n  expr: string;\n}\n\nexport interface VgAggregateTransform {\n  type: 'aggregate';\n  groupby?: VgFieldRef[];\n  fields?: VgFieldRef[];\n  ops?: AggregateOp[];\n  as?: string[];\n  cross?: boolean;\n  drop?: boolean;\n}\n\nexport interface VgCollectTransform {\n  type: 'collect';\n  sort: VgSort;\n}\n\nexport interface VgLookupTransform {\n  type: 'lookup';\n  from: string;\n  key: string;\n  fields: string[];\n  values?: string[];\n  as?: string[];\n  default?: string;\n}\n\nexport interface VgStackTransform {\n  type: 'stack';\n  offset?: StackOffset;\n  groupby: string[];\n  field: string;\n  sort: VgSort;\n  as: string[];\n}\n\nexport interface VgIdentifierTransform {\n  type: 'identifier';\n  as: string;\n}\n\nexport type VgTransform = VgBinTransform | VgExtentTransform | VgFormulaTransform | VgAggregateTransform | VgFilterTransform | VgImputeTransform | VgStackTransform | VgCollectTransform | VgLookupTransform | VgIdentifierTransform | VgGeoPointTransform | VgGeoJSONTransform | VgGeoJSONTransform | VgWindowTransform;\n\nexport interface VgGeoPointTransform {\n  type: 'geopoint';\n  projection: string; // projection name\n  fields: VgFieldRef[];\n  as?: string[];\n}\n\nexport interface VgGeoShapeTransform {\n  type: 'geoshape';\n  projection: string; // projection name\n  field?: VgFieldRef;\n  as?: string;\n}\n\nexport interface VgGeoJSONTransform {\n  type: 'geojson';\n  fields?: VgFieldRef[];\n  geojson?: VgFieldRef;\n  signal: string;\n}\n\nexport type VgPostEncodingTransform = VgGeoShapeTransform;\n\nexport interface VgAxisEncode {\n  ticks?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  title?: VgGuideEncode;\n  grid?: VgGuideEncode;\n  domain?: VgGuideEncode;\n}\n\nexport interface VgLegendEncode {\n  title?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  legend?: VgGuideEncode;\n  symbols?: VgGuideEncode;\n  gradient?: VgGuideEncode;\n}\n\nexport type VgGuideEncode = any; // TODO: replace this (See guideEncode in Vega Schema)\n\nexport type VgSort = {\n  field: string;\n  order?: VgComparatorOrder;\n} | {\n  field: string[];\n  order?: (VgComparatorOrder)[];\n};\n\nexport interface VgImputeTransform {\n  type: 'impute';\n  groupby?: string[];\n  field: string;\n  key: string;\n  keyvals?: string[];\n  method?: 'value' | 'median' | 'max' | 'min' | 'mean';\n  value?: any;\n}\n\nexport type VgCheckboxBinding = {\n  input: 'checkbox';\n  element?: string;\n};\n\nexport type VgRadioBinding = {\n  input: 'radio';\n  options: string[];\n  element?: string;\n};\n\nexport type VgSelectBinding = {\n  input: 'select';\n  options: string[];\n  element?: string;\n};\n\nexport type VgRangeBinding = {\n  input: 'range';\n  min?: number;\n  max?: number;\n  step?: number;\n  element?: string;\n};\n\nexport type VgGenericBinding = {\n  input: string;\n  element?: string;\n};\n\nexport type VgBinding = VgCheckboxBinding | VgRadioBinding |\n  VgSelectBinding | VgRangeBinding | VgGenericBinding;\n\n\n/**\n * Base object for Vega's Axis and Axis Config.\n * All of these properties are both properties of Vega's Axis and Axis Config.\n */\nexport interface VgAxisBase {\n  /**\n   * A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.\n   *\n   * __Default value:__ `true`\n   */\n  domain?: boolean;\n\n  /**\n   * A boolean flag indicating if grid lines should be included as part of the axis\n   *\n   * __Default value:__ `true` for [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned; otherwise, `false`.\n   */\n  grid?: boolean;\n\n  /**\n   * A boolean flag indicating if labels should be included as part of the axis.\n   *\n   * __Default value:__  `true`.\n   */\n  labels?: boolean;\n\n  /**\n   * Indicates if labels should be hidden if they exceed the axis range. If `false `(the default) no bounds overlap analysis is performed. If `true`, labels will be hidden if they exceed the axis range by more than 1 pixel. If this property is a number, it specifies the pixel tolerance: the maximum amount by which a label bounding box may exceed the axis range.\n   *\n   * __Default value:__ `false`.\n   */\n  labelBound?: boolean | number;\n\n  /**\n   * Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.\n   *\n   * __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.\n   */\n  labelFlush?: boolean | number;\n\n  /**\n   * The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `\"greedy\"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\n   *\n   * __Default value:__ `true` for non-nominal fields with non-log scales; `\"greedy\"` for log scales; otherwise `false`.\n   */\n  labelOverlap?: boolean | 'parity' | 'greedy';\n\n  /**\n   * The padding, in pixels, between axis and text labels.\n   */\n  labelPadding?: number;\n\n  /**\n   * Boolean value that determines whether the axis should include ticks.\n   */\n  ticks?: boolean;\n\n  /**\n   * The size in pixels of axis ticks.\n   *\n   * @minimum 0\n   */\n  tickSize?: number;\n\n  /**\n   * Max length for axis title if the title is automatically generated from the field's description.\n   *\n   * @minimum 0\n   * __Default value:__ `undefined`.\n   */\n  titleMaxLength?: number;\n\n  /**\n   * The padding, in pixels, between title and axis.\n   */\n  titlePadding?: number;\n\n  /**\n   * The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\n   *\n   * __Default value:__ `30` for y-axis; `undefined` for x-axis.\n   */\n  minExtent?: number;\n\n  /**\n   * The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\n   *\n   * __Default value:__ `undefined`.\n   */\n  maxExtent?: number;\n}\n\nexport interface VgAxisConfig extends VgAxisBase {\n  /**\n   * An interpolation fraction indicating where, for `band` scales, axis ticks should be positioned. A value of `0` places ticks at the left edge of their bands. A value of `0.5` places ticks in the middle of their bands.\n   */\n  bandPosition?: number;\n  /**\n   * Stroke width of axis domain line\n   *\n   * __Default value:__  (none, using Vega default).\n   */\n  domainWidth?: number;\n\n  /**\n   * Color of axis domain line.\n   *\n   * __Default value:__  (none, using Vega default).\n   */\n  domainColor?: string;\n\n  // ---------- Grid ----------\n  /**\n   * Color of gridlines.\n   */\n  gridColor?: string;\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the grid dash array.\n   */\n  gridDash?: number[];\n\n  /**\n   * The stroke opacity of grid (value between [0,1])\n   *\n   * __Default value:__ (`1` by default)\n   * @minimum 0\n   * @maximum 1\n   */\n  gridOpacity?: number;\n\n  /**\n   * The grid width, in pixels.\n   * @minimum 0\n   */\n  gridWidth?: number;\n\n  // ---------- Ticks ----------\n  /**\n   * The color of the axis's tick.\n   */\n  tickColor?: string;\n\n\n  /**\n   * The rotation angle of the axis labels.\n   *\n   * __Default value:__ `-90` for nominal and ordinal fields; `0` otherwise.\n   *\n   * @minimum -360\n   * @maximum 360\n   */\n  labelAngle?: number;\n\n  /**\n   * The color of the tick label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n\n  /**\n   * The font of the tick label.\n   */\n  labelFont?: string;\n\n  /**\n   * The font size of the label, in pixels.\n   *\n   * @minimum 0\n   */\n  labelFontSize?: number;\n\n  /**\n   * Maximum allowed pixel width of axis tick labels.\n   */\n  labelLimit?: number;\n\n  /**\n   * Boolean flag indicating if pixel position values should be rounded to the nearest integer.\n   */\n  tickRound?: boolean;\n\n  /**\n   * The width, in pixels, of ticks.\n   *\n   * @minimum 0\n   */\n  tickWidth?: number;\n\n  // ---------- Title ----------\n\n  /**\n   * Horizontal text alignment of axis titles.\n   */\n  titleAlign?: string;\n\n  /**\n   * Angle in degrees of axis titles.\n   */\n  titleAngle?: number;\n  /**\n   * Vertical text baseline for axis titles.\n   */\n  titleBaseline?: string;\n  /**\n   * Color of the title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * Font of the title. (e.g., `\"Helvetica Neue\"`).\n   */\n  titleFont?: string;\n\n  /**\n   * Font size of the title.\n   *\n   * @minimum 0\n   */\n  titleFontSize?: number;\n\n  /**\n   * Font weight of the title.\n   * This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`).\n   */\n  titleFontWeight?: FontWeight;\n\n  /**\n   * Maximum allowed pixel width of axis titles.\n   */\n  titleLimit?: number;\n\n  /**\n   * X-coordinate of the axis title relative to the axis group.\n   */\n  titleX?: number;\n\n  /**\n   * Y-coordinate of the axis title relative to the axis group.\n   */\n  titleY?: number;\n}\n\nexport type LegendOrient = 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'none';\n\nexport interface VgLegendBase {\n  /**\n   * Padding (in pixels) between legend entries in a symbol legend.\n   */\n  entryPadding?: number;\n\n\n  /**\n   * The orientation of the legend, which determines how the legend is positioned within the scene. One of \"left\", \"right\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\", \"none\".\n   *\n   * __Default value:__ `\"right\"`\n   */\n  orient?: LegendOrient;\n\n  /**\n   * The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.\n   *\n   * __Default value:__  `0`\n   */\n  offset?: number;\n\n  /**\n   * The padding, in pixels, between the legend and axis.\n   */\n  padding?: number;\n}\n\nexport interface VgLegendConfig extends VgLegendBase {\n\n  /**\n   * Corner radius for the full legend.\n   */\n  cornerRadius?: number;\n\n  /**\n   * Background fill color for the full legend.\n   */\n  fillColor?: string;\n\n  /**\n   * Border stroke color for the full legend.\n   */\n  strokeColor?: string;\n\n  /**\n   * Border stroke dash pattern for the full legend.\n   */\n  strokeDash?: number[];\n\n  /**\n   * Border stroke width for the full legend.\n   */\n  strokeWidth?: number;\n  // ---------- Gradient ----------\n  /**\n   * The color of the gradient stroke, can be in hex color code or regular color name.\n   */\n  gradientStrokeColor?: string;\n\n  /**\n   * The width of the gradient stroke, in pixels.\n   * @minimum 0\n   */\n  gradientStrokeWidth?: number;\n\n  /**\n   * The height of the gradient, in pixels.\n   * @minimum 0\n   */\n  gradientHeight?: number;\n\n  /**\n   * Text baseline for color ramp gradient labels.\n   */\n  gradientLabelBaseline?: string;\n\n  /**\n   * The maximum allowed length in pixels of color ramp gradient labels.\n   */\n  gradientLabelLimit?: number;\n\n  /**\n   * Vertical offset in pixels for color ramp gradient labels.\n   */\n  gradientLabelOffset?: number;\n\n  /**\n   * The width of the gradient, in pixels.\n   * @minimum 0\n   */\n  gradientWidth?: number;\n\n  // ---------- Label ----------\n  /**\n   * The alignment of the legend label, can be left, middle or right.\n   */\n  labelAlign?: string;\n\n  /**\n   * The position of the baseline of legend label, can be top, middle or bottom.\n   */\n  labelBaseline?: string;\n\n  /**\n   * The color of the legend label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n\n  /**\n   * The font of the legend label.\n   */\n  labelFont?: string;\n\n  /**\n   * The font size of legend label.\n   *\n   * __Default value:__ `10`.\n   *\n   * @minimum 0\n   */\n  labelFontSize?: number;\n\n  /**\n   * Maximum allowed pixel width of axis tick labels.\n   */\n  labelLimit?: number;\n\n  /**\n   * The offset of the legend label.\n   * @minimum 0\n   */\n  labelOffset?: number;\n\n  // ---------- Symbols ----------\n  /**\n   * The color of the legend symbol,\n   */\n  symbolColor?: string;\n\n  /**\n   * Default shape type (such as \"circle\") for legend symbols.\n   */\n  symbolType?: string;\n\n  /**\n   * The size of the legend symbol, in pixels.\n   * @minimum 0\n   */\n  symbolSize?: number;\n\n  /**\n   * The width of the symbol's stroke.\n   * @minimum 0\n   */\n  symbolStrokeWidth?: number;\n\n  // ---------- Title ----------\n  /**\n   * Horizontal text alignment for legend titles.\n   */\n  titleAlign?: string;\n\n   /**\n    * Vertical text baseline for legend titles.\n    */\n  titleBaseline?: string;\n  /**\n   * The color of the legend title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * The font of the legend title.\n   */\n  titleFont?: string;\n\n  /**\n   * The font size of the legend title.\n   */\n  titleFontSize?: number;\n\n  /**\n   * The font weight of the legend title.\n   * This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`).\n   */\n  titleFontWeight?: FontWeight;\n\n  /**\n   * Maximum allowed pixel width of axis titles.\n   */\n  titleLimit?: number;\n\n  /**\n   * The padding, in pixels, between title and legend.\n   */\n  titlePadding?: number;\n}\n\nexport type FontStyle = 'normal' | 'italic';\n\nexport type FontWeightString = 'normal' | 'bold';\n/**\n * @TJS-type integer\n * @minimum 100\n * @maximum 900\n */\nexport type FontWeightNumber = number;\nexport type FontWeight = FontWeightString | FontWeightNumber;\nexport type HorizontalAlign = 'left' | 'right' | 'center';\nexport type Interpolate = 'linear' | 'linear-closed' |\n  'step' | 'step-before' | 'step-after' |\n  'basis' | 'basis-open' | 'basis-closed' |\n  'cardinal' | 'cardinal-open' | 'cardinal-closed' |\n  'bundle' | 'monotone';\nexport type Orient = 'horizontal' | 'vertical';\nexport type VerticalAlign = 'top' | 'middle' | 'bottom';\nexport type Cursor = 'auto' | 'default' | 'none' |\n  'context-menu' | 'help' | 'pointer' |\n  'progress' | 'wait' | 'cell' |\n  'crosshair' | 'text' | 'vertical-text' |\n  'alias' | 'copy' | 'move' |\n  'no-drop' | 'not-allowed' | 'e-resize' |\n  'n-resize' | 'ne-resize' | 'nw-resize' |\n  's-resize' | 'se-resize' | 'sw-resize' |\n  'w-resize' | 'ew-resize' | 'ns-resize' |\n  'nesw-resize' | 'nwse-resize' | 'col-resize' |\n  'row-resize' | 'all-scroll' | 'zoom-in' |\n  'zoom-out' | 'grab' | 'grabbing';\nexport type StrokeCap = 'butt' | 'round' | 'square';\nexport type StrokeJoin = 'miter' | 'round' | 'bevel';\nexport type Dir = 'ltr' | 'rtl';\n\nexport interface VgMarkConfig {\n\n  /**\n   * Default Fill Color.  This has higher precedence than `config.color`\n   *\n   * __Default value:__ (None)\n   *\n   */\n  fill?: string;\n\n  /**\n   * Default Stroke Color.  This has higher precedence than `config.color`\n   *\n   * __Default value:__ (None)\n   *\n   */\n  stroke?: string;\n\n  // ---------- Opacity ----------\n  /**\n   * The overall opacity (value between [0,1]).\n   *\n   * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  opacity?: number;\n\n\n  /**\n   * The fill opacity (value between [0,1]).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  fillOpacity?: number;\n\n  /**\n   * The stroke opacity (value between [0,1]).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  strokeOpacity?: number;\n\n  // ---------- Stroke Style ----------\n  /**\n   * The stroke width, in pixels.\n   *\n   * @minimum 0\n   */\n  strokeWidth?: number;\n\n  /**\n   * The stroke cap for line ending style. One of `\"butt\"`, `\"round\"`, or `\"square\"`.\n   *\n   * __Default value:__ `\"square\"`\n   */\n  strokeCap?: StrokeCap;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   */\n  strokeDashOffset?: number;\n\n  /**\n   * The stroke line join method. One of `\"miter\"`, `\"round\"` or `\"bevel\"`.\n   *\n   * __Default value:__ `\"miter\"`\n   */\n  strokeJoin?: StrokeJoin;\n\n  /**\n   * The miter limit at which to bevel a line join.\n   */\n  strokeMiterLimit?: number;\n\n  // ---------- Orientation: Bar, Tick, Line, Area ----------\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line and trail marks, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  // ---------- Interpolation: Line / area ----------\n  /**\n   * The line interpolation method to use for line and area marks. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n  /**\n   * Depending on the interpolation type, sets the tension parameter (for line and area marks).\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n\n  /**\n   * The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   *\n   * __Default value:__ `\"circle\"`\n   *\n   */\n  shape?: string;\n\n  /**\n   * The pixel area each the point/circle/square.\n   * For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   *\n   * __Default value:__ `30`\n   *\n   * @minimum 0\n   */\n  size?: number;\n\n  // Text / Label Mark Config\n\n  /**\n   * The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`.\n   */\n  align?: HorizontalAlign;\n\n  /**\n   * The rotation angle of the text, in degrees.\n   * @minimum 0\n   * @maximum 360\n   */\n  angle?: number;\n\n  /**\n   * The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n   *\n   * __Default value:__ `\"middle\"`\n   *\n   */\n  baseline?: VerticalAlign;\n\n  /**\n   * The direction of the text. One of `\"ltr\"` (left-to-right) or `\"rtl\"` (right-to-left). This property determines on which side is truncated in response to the limit parameter.\n   *\n   * __Default value:__ `\"ltr\"`\n   */\n  dir?: Dir;\n\n  /**\n   * The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.\n   */\n  dx?: number;\n\n  /**\n   * The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.\n   */\n  dy?: number;\n\n  /**\n   * Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.\n   * @minimum 0\n   */\n  radius?: number;\n\n  /**\n   * The maximum length of the text mark in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n   *\n   * __Default value:__ `0`, indicating no limit\n   */\n  limit?: number;\n\n  /**\n   * The ellipsis string for text truncated in response to the limit parameter.\n   *\n   * __Default value:__ `\"…\"`\n   */\n  ellipsis?: string;\n\n  /**\n   * Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".\n   */\n  theta?: number;\n\n  /**\n   * The typeface to set the text in (e.g., `\"Helvetica Neue\"`).\n   */\n  font?: string;\n\n  /**\n   * The font size, in pixels.\n   * @minimum 0\n   */\n  fontSize?: number;\n\n  /**\n   * The font style (e.g., `\"italic\"`).\n   */\n  fontStyle?: FontStyle;\n  /**\n   * The font weight.\n   * This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`).\n   */\n  fontWeight?: FontWeight;\n\n  /**\n   * Placeholder text if the `text` channel is not specified\n   */\n  text?: string;\n\n  /**\n   * A URL to load upon mouse click. If defined, the mark acts as a hyperlink.\n   *\n   * @format uri\n   */\n  href?: string;\n\n  /**\n   * The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.\n   */\n  cursor?: Cursor;\n\n  /**\n   * The tooltip text to show upon mouse hover.\n   */\n  tooltip?: any;\n\n  // ---------- Corner Radius: Bar, Tick, Rect ----------\n\n  /**\n   * The radius in pixels of rounded rectangle corners.\n   *\n   * __Default value:__ `0`\n   */\n  cornerRadius?: number;\n}\n\nconst VG_MARK_CONFIG_INDEX: Flag<keyof VgMarkConfig> = {\n  opacity: 1,\n  fill: 1,\n  fillOpacity: 1,\n  stroke: 1,\n  strokeCap: 1,\n  strokeWidth: 1,\n  strokeOpacity: 1,\n  strokeDash: 1,\n  strokeDashOffset: 1,\n  strokeJoin: 1,\n  strokeMiterLimit: 1,\n  size: 1,\n  shape: 1,\n  interpolate: 1,\n  tension: 1,\n  orient: 1,\n  align: 1,\n  baseline: 1,\n  text: 1,\n  dir: 1,\n  dx: 1,\n  dy: 1,\n  ellipsis: 1,\n  limit: 1,\n  radius: 1,\n  theta: 1,\n  angle: 1,\n  font: 1,\n  fontSize: 1,\n  fontWeight: 1,\n  fontStyle: 1,\n  cursor: 1,\n  href: 1,\n  tooltip: 1,\n  cornerRadius: 1,\n  // commented below are vg channel that do not have mark config.\n  // 'x'|'x2'|'xc'|'width'|'y'|'y2'|'yc'|'height'\n  // clip: 1,\n  // endAngle: 1,\n  // innerRadius: 1,\n  // outerRadius: 1,\n  // path: 1,\n  // startAngle: 1,\n  // url: 1,\n};\n\nexport const VG_MARK_CONFIGS = flagKeys(VG_MARK_CONFIG_INDEX);\n\nexport type Anchor = 'start' | 'middle' | 'end';\n\nexport interface VgTitle {\n  /**\n   * The title text.\n   */\n  text: string;\n\n  /**\n   * The orientation of the title relative to the chart. One of `\"top\"` (the default), `\"bottom\"`, `\"left\"`, or `\"right\"`.\n   */\n  orient?: TitleOrient;\n\n  /**\n   * The anchor position for placing the title. One of `\"start\"`, `\"middle\"` (the default), or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\n   */\n  anchor?: Anchor;\n\n  /**\n   * The orthogonal offset in pixels by which to displace the title from its position along the edge of the chart.\n   */\n  offset?: number;\n\n  style?: string | string[];\n\n  // TODO: name, encode, interactive, zindex\n}\n\nexport type TitleOrient = 'top' | 'bottom' | 'left' | 'right';\n\nexport interface VgTitleConfig {\n  /**\n   * The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\n   *\n   * __Default value:__ `\"middle\"` for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views.\n   * `\"start\"` for other composite views.\n   *\n   * __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views.  For other composite views, `anchor` is always `\"start\"`.\n   */\n  anchor?: Anchor;\n  /**\n   * Angle in degrees of title text.\n   */\n  angle?:\tnumber;\n  /**\n   * Vertical text baseline for title text.\n   */\n  baseline?: VerticalAlign;\n  /**\n   * Text color for title text.\n   */\n  color?:\tstring;\n  /**\n   * Font name for title text.\n   */\n  font?:\tstring;\n  /**\n   * Font size in pixels for title text.\n   *\n   * __Default value:__ `10`.\n   *\n   * @minimum 0\n   */\n  fontSize?:\tnumber;\n  /**\n   * Font weight for title text.\n   * This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`).\n   */\n  fontWeight?: FontWeight;\n  /**\n   * The maximum allowed length in pixels of legend labels.\n   *\n   * @minimum 0\n   */\n  limit?:\tnumber;\n  /**\n   * Offset in pixels of the title from the chart body and axes.\n   */\n  offset?:\tnumber;\n  /**\n   * Default title orientation (\"top\", \"bottom\", \"left\", or \"right\")\n   */\n  orient?: TitleOrient;\n}\n\nexport type VgComparatorOrder = 'ascending' | 'descending';\n\nexport interface VgComparator {\n  field?: string | string[];\n  order?: VgComparatorOrder | VgComparatorOrder[];\n}\n\nexport interface VgWindowTransform {\n  type: 'window';\n  params?: Number[];\n  as?: string[];\n  ops?: (AggregateOp | WindowOnlyOp)[];\n  fields?: string[];\n  frame?: Number[];\n  ignorePeers?: Boolean;\n  groupby?: string[];\n  sort?: VgComparator;\n}\n"]}