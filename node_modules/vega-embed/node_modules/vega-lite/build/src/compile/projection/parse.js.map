{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/projection/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {MAIN} from '../../data';\nimport {PROJECTION_PROPERTIES} from '../../projection';\nimport {GEOJSON} from '../../type';\nimport {duplicate, every, stringify} from '../../util';\nimport {VgSignalRef} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {ProjectionComponent} from './component';\n\nexport function parseProjection(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.projection = parseUnitProjection(model);\n  } else {\n    // because parse happens from leaves up (unit specs before layer spec),\n    // we can be sure that the above if statement has already occurred\n    // and therefore we have access to child.component.projection\n    // for each of model's children\n    model.component.projection = parseNonUnitProjections(model);\n  }\n}\n\nfunction parseUnitProjection(model: UnitModel): ProjectionComponent {\n  const {specifiedProjection, config, hasProjection} = model;\n\n  if (hasProjection) {\n    const data: (VgSignalRef | string)[] = [];\n\n    [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]].forEach((posssiblePair) => {\n      if (model.channelHasField(posssiblePair[0]) || model.channelHasField(posssiblePair[1])) {\n        data.push({\n          signal: model.getName(`geojson_${data.length}`)\n        });\n      }\n    });\n\n    if (model.channelHasField(SHAPE) && model.fieldDef(SHAPE).type === GEOJSON) {\n      data.push({\n        signal: model.getName(`geojson_${data.length}`)\n      });\n    }\n\n    if (data.length === 0) {\n      // main source is geojson, so we can just use that\n      data.push(model.requestDataName(MAIN));\n    }\n\n    return new ProjectionComponent(model.projectionName(true), {\n      ...(config.projection || {}),\n      ...(specifiedProjection || {}),\n    }, [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')], data);\n  }\n\n  return undefined;\n}\n\n\nfunction mergeIfNoConflict(first: ProjectionComponent, second: ProjectionComponent): ProjectionComponent {\n  const allPropertiesShared = every(PROJECTION_PROPERTIES, (prop) => {\n    // neither has the poperty\n    if (!first.explicit.hasOwnProperty(prop) &&\n      !second.explicit.hasOwnProperty(prop)) {\n      return true;\n    }\n    // both have property and an equal value for property\n    if (first.explicit.hasOwnProperty(prop) &&\n      second.explicit.hasOwnProperty(prop) &&\n      // some properties might be signals or objects and require hashing for comparison\n      stringify(first.get(prop)) === stringify(second.get(prop))) {\n      return true;\n    }\n    return false;\n  });\n\n  const size = stringify(first.size) === stringify(second.size);\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (stringify(first.explicit) === stringify({})) {\n      return second;\n    } else if (stringify(second.explicit) === stringify({})) {\n      return first;\n    }\n  }\n\n  // if all properties don't match, let each unit spec have its own projection\n  return null;\n}\n\nfunction parseNonUnitProjections(model: Model): ProjectionComponent {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  let nonUnitProjection: ProjectionComponent;\n  const mergable = every(model.children, (child) => {\n    parseProjection(child);\n    const projection = child.component.projection;\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      const merge = mergeIfNoConflict(nonUnitProjection, projection);\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n      return !!merge;\n    }\n  });\n\n  // it cached one and all other children share the same projection,\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    const name = model.projectionName(true);\n    const modelProjection = new ProjectionComponent(\n      name,\n      nonUnitProjection.specifiedProjection,\n      nonUnitProjection.size,\n      duplicate(nonUnitProjection.data)\n    );\n\n    // rename and assign all others as merged\n    model.children.forEach((child) => {\n      if (child.component.projection) {\n        modelProjection.data = modelProjection.data.concat(child.component.projection.data);\n        child.renameProjection(child.component.projection.get('name'), name);\n        child.component.projection.merged = true;\n      }\n    });\n\n    return modelProjection;\n  }\n\n  return undefined;\n}\n"]}