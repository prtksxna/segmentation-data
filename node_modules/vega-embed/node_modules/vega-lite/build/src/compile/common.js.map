{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/compile/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {Channel, isScaleChannel} from '../channel';\nimport {Config, ViewConfig} from '../config';\nimport {FieldDef, FieldDefBase, FieldRefOption, isScaleFieldDef, isTimeFieldDef, OrderFieldDef, ValueDef, vgField} from '../fielddef';\nimport {GuideEncodingEntry} from '../guide';\nimport {MarkConfig, MarkDef, TextConfig} from '../mark';\nimport {ScaleType} from '../scale';\nimport {formatExpression, TimeUnit} from '../timeunit';\nimport {QUANTITATIVE} from '../type';\nimport {contains, keys, stringify} from '../util';\nimport {VgEncodeChannel, VgEncodeEntry, VgMarkConfig, VgSort} from '../vega.schema';\nimport {AxisComponentProps} from './axis/component';\nimport {wrapCondition} from './mark/mixins';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\n\nexport function applyConfig(e: VgEncodeEntry,\n    config: ViewConfig | MarkConfig | TextConfig, // TODO(#1842): consolidate MarkConfig | TextConfig?\n    propsList: string[]) {\n  for (const property of propsList) {\n    const value = config[property];\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style || []);\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(prop: P, mark: MarkDef, config: Config): MarkConfig[P] {\n  // By default, read from mark config first!\n  let value = config.mark[prop];\n\n  // Then read mark specific config, which has higher precedence\n  const markSpecificConfig = config[mark.type];\n  if (markSpecificConfig[prop] !== undefined) {\n    value = markSpecificConfig[prop];\n  }\n\n  // Then read style config, which has even higher precedence.\n  const styles = getStyles(mark);\n  for (const style of styles) {\n    const styleConfig = config.style[style];\n\n    // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n    const p = prop as keyof VgMarkConfig;\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n\n  return value;\n}\n\nexport function formatSignalRef(fieldDef: FieldDef<string>, specifiedFormat: string, expr: 'datum' | 'parent', config: Config) {\n  const format = numberFormat(fieldDef, specifiedFormat, config);\n  if (fieldDef.bin) {\n    const startField = vgField(fieldDef, {expr});\n    const endField = vgField(fieldDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(startField, endField, format, config)\n    };\n  } else if (fieldDef.type === 'quantitative') {\n    return {\n      signal: `${formatExpr(vgField(fieldDef, {expr, binSuffix: 'range'}), format)}`\n    };\n  } else if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(vgField(fieldDef, {expr}), fieldDef.timeUnit, specifiedFormat, config.text.shortTimeLabels, config.timeFormat, isUTCScale, true)\n    };\n  } else {\n    return {\n      signal: `''+${vgField(fieldDef, {expr})}`\n    };\n  }\n}\n\nexport function getSpecifiedOrDefaultValue<T>(specifiedValue: T, defaultValue: T | {signal: string}) {\n  if (specifiedValue !== undefined) {\n    return specifiedValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns number format for a fieldDef\n *\n * @param format explicitly specified format\n */\nexport function numberFormat(fieldDef: FieldDef<string>, specifiedFormat: string, config: Config) {\n  if (fieldDef.type === QUANTITATIVE) {\n    // add number format for quantitative type only\n\n    // Specified format in axis/legend has higher precedence than fieldDef.format\n    if (specifiedFormat) {\n      return specifiedFormat;\n    }\n\n    // TODO: need to make this work correctly for numeric ordinal / nominal type\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nexport function numberFormatExpr(field: string, specifiedFormat: string, config: Config) {\n  return formatExpr(field, specifiedFormat || config.numberFormat);\n}\n\n\nexport function binFormatExpression(startField: string, endField: string, format: string, config: Config) {\n  return `${startField} === null || isNaN(${startField}) ? \"null\" : ${numberFormatExpr(startField, format, config)} + \" - \" + ${numberFormatExpr(endField, format, config)}`;\n}\n\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(field: string, timeUnit: TimeUnit, format: string, shortTimeLabels: boolean, timeFormatConfig: string, isUTCScale: boolean, alwaysReturn: boolean = false): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format || timeFormatConfig; // only use config.timeFormat if there is no timeUnit.\n\n    if (format || alwaysReturn) {\n      return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels, isUTCScale);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef: OrderFieldDef<string> | OrderFieldDef<string>[], fieldRefOption?: FieldRefOption): VgSort {\n  return (isArray(orderDef) ? orderDef : [orderDef]).reduce((s, orderChannelDef) => {\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push(orderChannelDef.sort || 'ascending');\n    return s;\n  }, {field:[], order: []});\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: FieldDefBase<string>[], f2: FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach((fdToMerge) => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (stringify(fieldDef1) === stringify(fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: string, title2: string) {\n  return title1 === title2 ?\n    title1 : // if title is the same just use one of them\n    title1 + ', ' + title2; // join title with comma if different\n}\n\nexport function mergeTitleComponent(\n  v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>\n) {\n  if (isArray(v1.value) && isArray(v2.value)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1.value, v2.value)\n    };\n  } else if (!isArray(v1.value) && !isArray(v2.value)) {\n    return {\n      explicit: v1.explicit, // keep the old explicit\n      value: mergeTitle(v1.value, v2.value)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef: FieldDef<string>, channel: Channel) {\n  if (!fieldDef.bin) {\n    console.warn('Only use this method with binned field defs');\n    return false;\n  }\n\n  // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n  return isScaleChannel(channel) && contains(['ordinal', 'nominal'], fieldDef.type);\n}\n\nexport function guideEncodeEntry(encoding: GuideEncodingEntry, model: UnitModel) {\n  return keys(encoding).reduce((encode, channel: VgEncodeChannel) => {\n    const valueDef = encoding[channel];\n    return {\n      ...encode,\n      ...wrapCondition(model, valueDef, channel, (x: ValueDef) => ({value: x.value}))\n    };\n  }, {});\n}\n"]}