{"version":3,"file":"init.js","sourceRoot":"","sources":["../../../../src/compile/mark/init.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport {Config} from '../../config';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {FieldDef, isContinuous, isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {AREA, BAR, CIRCLE, isMarkDef, LINE, Mark, MarkDef, POINT, RECT, RULE, SQUARE, TEXT, TICK} from '../../mark';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains} from '../../util';\nimport {getMarkConfig} from '../common';\nimport {Orient} from './../../vega.schema';\n\n\nexport function normalizeMarkDef(mark: Mark | MarkDef, encoding: Encoding<string>, config: Config) {\n  const markDef: MarkDef = isMarkDef(mark) ? {...mark} : {type: mark};\n\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  const specifiedOrient = markDef.orient || getMarkConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient,specifiedOrient));\n  }\n\n  // set opacity and filled if not specified in mark config\n  const specifiedOpacity = markDef.opacity !== undefined ? markDef.opacity : getMarkConfig('opacity', markDef, config);\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n\n  const specifiedFilled = markDef.filled;\n  if (specifiedFilled === undefined) {\n    markDef.filled = filled(markDef, config);\n  }\n\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  const specifiedCursor = markDef.cursor || getMarkConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef: MarkDef, encoding: Encoding<String>, config: Config) {\n  if (encoding.href || markDef.href || getMarkConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\n\nfunction opacity(mark: Mark, encoding: Encoding<string>) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\n\nfunction filled(markDef: MarkDef, config: Config) {\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return filledConfig !== undefined ? filledConfig : mark !== POINT && mark !== LINE && mark !== RULE;\n}\n\nfunction orient(mark: Mark, encoding: Encoding<string>, specifiedOrient: Orient): Orient {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const yIsRange = encoding.y2;\n  const xIsRange = encoding.x2;\n\n  switch (mark) {\n    case BAR:\n      if (yIsRange || xIsRange) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n\n        // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n        const xDef = encoding.x;\n        if (!xIsRange && isFieldDef(xDef) && xDef.type === QUANTITATIVE && !xDef.bin) {\n          return 'horizontal';\n        }\n\n        // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n        const yDef = encoding.y;\n        if (!yIsRange && isFieldDef(yDef) && yDef.type === QUANTITATIVE && !yDef.bin) {\n          return 'vertical';\n        }\n      }\n      /* tslint:disable */\n    case RULE: // intentionally fall through\n      // return undefined for line segment rule and bar with both axis ranged\n      if (xIsRange && yIsRange) {\n        return undefined;\n      }\n\n    case AREA: // intentionally fall through\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (yIsRange) {\n        return 'vertical';\n      } else if (xIsRange) {\n        return 'horizontal';\n      } else if (mark === RULE) {\n        if (encoding.x && !encoding.y) {\n          return 'vertical';\n        } else if (encoding.y && !encoding.x) {\n          return 'horizontal';\n        }\n      }\n\n\n    case LINE: // intentional fall through\n    case TICK: // Tick is opposite to bar, line, area and never have ranged mark.\n\n      /* tslint:enable */\n      const xIsContinuous = isFieldDef(encoding.x) && isContinuous(encoding.x);\n      const yIsContinuous = isFieldDef(encoding.y) && isContinuous(encoding.y);\n      if (xIsContinuous && !yIsContinuous) {\n        return mark !== 'tick' ? 'horizontal' : 'vertical';\n      } else if (!xIsContinuous && yIsContinuous) {\n        return mark !== 'tick' ? 'vertical' : 'horizontal';\n      } else if (xIsContinuous && yIsContinuous) {\n        const xDef = encoding.x as FieldDef<string>; // we can cast here since they are surely fieldDef\n        const yDef = encoding.y as FieldDef<string>;\n\n        const xIsTemporal = xDef.type === TEMPORAL;\n        const yIsTemporal = yDef.type === TEMPORAL;\n\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xIsTemporal && !yIsTemporal) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (!xDef.aggregate && yDef.aggregate) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xDef.aggregate && !yDef.aggregate) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return 'vertical';\n      } else {\n        // Discrete x Discrete case\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return undefined;\n      }\n  }\n  return 'vertical';\n}\n\n"]}