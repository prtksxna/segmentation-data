{"version":3,"file":"mixins.js","sourceRoot":"","sources":["../../../../src/compile/mark/mixins.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\n\nimport {NONPOSITION_SCALE_CHANNELS, PositionScaleChannel} from '../../channel';\nimport {\n  ChannelDef,\n  FieldDef,\n  FieldDefWithCondition,\n  getFieldDef,\n  isConditionalSelection,\n  isValueDef,\n  TextFieldDef,\n  ValueDefWithCondition,\n  vgField,\n} from '../../fielddef';\nimport * as log from '../../log';\nimport {MarkDef} from '../../mark';\nimport {expression} from '../../predicate';\nimport {hasContinuousDomain} from '../../scale';\nimport {contains} from '../../util';\nimport {VG_MARK_CONFIGS, VgEncodeEntry, VgValueRef} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {selectionPredicate} from '../selection/selection';\nimport {UnitModel} from '../unit';\nimport * as ref from './valueref';\n\nexport function color(model: UnitModel, opt: {valueOnly: boolean} = {valueOnly: false}): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {filled, type: markType} = markDef;\n\n  const configValue = {\n    fill: getMarkConfig('fill', markDef, config),\n    stroke: getMarkConfig('stroke', markDef, config),\n    color: getMarkConfig('color', markDef, config)\n  };\n\n  const transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType) ? 'transparent' : undefined;\n\n  const defaultValue = {\n    fill: markDef.fill || configValue.fill ||\n    // If there is no fill, always fill symbols, bar, geoshape\n    // with transparent fills https://github.com/vega/vega-lite/issues/1316\n      transparentIfNeeded,\n    stroke: markDef.stroke || configValue.stroke\n  };\n\n  const colorVgChannel = filled ? 'fill' : 'stroke';\n\n  const fillStrokeMarkDefAndConfig: VgEncodeEntry = {\n    ...(defaultValue.fill ? {\n      fill: {value: defaultValue.fill}\n    } : {}),\n    ...(defaultValue.stroke ? {\n      stroke: {value: defaultValue.stroke}\n    } : {}),\n  };\n\n  if (encoding.fill || encoding.stroke) {\n    // ignore encoding.color, markDef.color, config.color\n    if (markDef.color) {\n      // warn for markDef.color  (no need to warn encoding.color as it will be dropped in normalized already)\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n    }\n\n    return {\n      ...nonPosition('fill', model, {defaultValue: defaultValue.fill || transparentIfNeeded}),\n      ...nonPosition('stroke', model, {defaultValue: defaultValue.stroke})\n    };\n  } else if (encoding.color) {\n\n    return {\n      ...fillStrokeMarkDefAndConfig,\n      // override them with encoded color field\n      ...nonPosition('color', model, {\n        vgChannel: colorVgChannel,\n        // apply default fill/stroke first, then color config, then transparent if needed.\n        defaultValue: markDef[colorVgChannel] || markDef.color || configValue[colorVgChannel] || configValue.color || (filled ? transparentIfNeeded : undefined)\n      })\n    };\n  } else if (markDef.fill || markDef.stroke) {\n    // Ignore markDef.color, config.color\n    if (markDef.color) {\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in markDef, stroke: 'stroke' in markDef}));\n    }\n    return fillStrokeMarkDefAndConfig;\n  } else if (markDef.color) {\n    return {\n      ...fillStrokeMarkDefAndConfig, // in this case, fillStrokeMarkDefAndConfig only include config\n\n      // override config with markDef.color\n      [colorVgChannel]: {value: markDef.color}\n    };\n  } else if (configValue.fill || configValue.stroke) {\n    // ignore config.color\n    return fillStrokeMarkDefAndConfig;\n  } else if (configValue.color) {\n    return {\n      ...(transparentIfNeeded ? {fill: {value: 'transparent'}} : {}),\n      [colorVgChannel]: {value: configValue.color}\n    };\n  }\n  return {};\n}\n\nexport type Ignore = Record<'size' | 'orient', 'ignore' | 'include'>;\n\nexport function baseEncodeEntry(model: UnitModel, ignore: Ignore) {\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...color(model),\n    ...nonPosition('opacity', model),\n    ...tooltip(model),\n    ...text(model, 'href')\n  };\n}\n\nfunction markDefProperties(mark: MarkDef, ignore: Ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop: string, value: string | number | boolean): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: {value: value}};\n  }\n  return undefined;\n}\n\nfunction validPredicate(vgRef: string) {\n  return `${vgRef} !== null && !isNaN(${vgRef})`;\n}\n\nexport function defined(model: UnitModel): VgEncodeEntry {\n  if (model.config.invalidValues === 'filter') {\n    const fields = ['x', 'y'].map((channel: PositionScaleChannel) => {\n        const scaleComponent = model.getScaleComponent(channel);\n        if (scaleComponent) {\n          const scaleType = scaleComponent.get('type');\n\n          // Discrete domain scales can handle invalid values, but continuous scales can't.\n          if (hasContinuousDomain(scaleType)) {\n            return model.vgField(channel, {expr: 'datum'});\n          }\n        }\n        return undefined;\n      })\n      .filter(field => !!field)\n      .map(validPredicate);\n\n    if (fields.length > 0) {\n      return {\n        defined: {signal: fields.join(' && ')}\n      };\n    }\n  }\n\n  return {};\n}\n\n/**\n * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)\n */\nexport function nonPosition(channel: typeof NONPOSITION_SCALE_CHANNELS[0], model: UnitModel, opt: {defaultValue?: number | string | boolean, vgChannel?: string, defaultRef?: VgValueRef} = {}): VgEncodeEntry {\n  const {defaultValue, vgChannel} = opt;\n  const defaultRef = opt.defaultRef || (defaultValue !== undefined ? {value: defaultValue} : undefined);\n\n  const channelDef = model.encoding[channel];\n\n  return wrapCondition(model, channelDef, vgChannel || channel, (cDef) => {\n    return ref.midPoint(\n      channel, cDef, model.scaleName(channel),\n      model.getScaleComponent(channel),\n      null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    );\n  });\n}\n\n/**\n * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(\n    model: UnitModel, channelDef: ChannelDef<string>, vgChannel: string,\n    refFn: (cDef: ChannelDef<string>) => VgValueRef\n  ): VgEncodeEntry {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n  if (condition) {\n    const conditions = isArray(condition) ? condition : [condition];\n    const vgConditions = conditions.map((c) => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c) ? selectionPredicate(model, c.selection) : expression(model, c.test);\n      return {\n        test,\n        ...conditionValueRef\n      };\n    });\n    return {\n      [vgChannel]: [\n        ...vgConditions,\n        ...(valueRef !== undefined ? [valueRef] : [])\n      ]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n\nexport function tooltip(model: UnitModel) {\n  const channel = 'tooltip';\n  const channelDef = model.encoding[channel];\n  if (isArray(channelDef)) {\n    const keyValues = channelDef.map((fieldDef) => {\n      const key = fieldDef.title !== undefined ? fieldDef.title : vgField(fieldDef, {binSuffix: 'range'});\n      const value = ref.text(fieldDef, model.config).signal;\n      return `\"${key}\": ${value}`;\n    });\n    return {tooltip: {signal: `{${keyValues.join(', ')}}`}};\n  } else {\n    // if not an array, behave just like text\n    return textCommon(model, channel, channelDef);\n  }\n}\n\nexport function text(model: UnitModel, channel: 'text' | 'href' = 'text') {\n  const channelDef = model.encoding[channel];\n  return textCommon(model, channel, channelDef);\n}\n\nfunction textCommon(model: UnitModel, channel: 'text' | 'href' | 'tooltip', channelDef: FieldDefWithCondition<TextFieldDef<string>> | ValueDefWithCondition<TextFieldDef<string>>) {\n  return wrapCondition(model, channelDef, channel, (cDef) => ref.text(cDef, model.config));\n}\n\nexport function bandPosition(fieldDef: FieldDef<string>, channel: 'x'|'y', model: UnitModel) {\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  if (model.encoding.size || model.markDef.size !== undefined) {\n    const orient = model.markDef.orient;\n    if (orient) {\n      const centeredBandPositionMixins = {\n        // Use xc/yc and place the mark at the middle of the band\n        // This way we never have to deal with size's condition for x/y position.\n        [channel+'c']: ref.fieldRef(fieldDef, scaleName, {}, {band: 0.5})\n      };\n\n      if (getFieldDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (isValueDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (model.markDef.size !== undefined) {\n        return {\n          ...centeredBandPositionMixins,\n          [sizeChannel]: {value: model.markDef.size}\n        };\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(model.markDef.type));\n    }\n  }\n  return {\n    [channel]: ref.fieldRef(fieldDef, scaleName, {binSuffix: 'range'}),\n    [sizeChannel]: ref.bandRef(scaleName)\n  };\n}\n\nexport function centeredBandPosition(channel: 'x' | 'y', model: UnitModel, defaultPosRef: VgValueRef, defaultSizeRef: VgValueRef) {\n  const centerChannel: 'xc' | 'yc' = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    ...pointPosition(channel, model, defaultPosRef, centerChannel),\n    ...nonPosition('size', model, {defaultRef: defaultSizeRef, vgChannel: sizeChannel})\n  };\n}\n\nexport function binnedPosition(fieldDef: FieldDef<string>, channel: 'x'|'y', scaleName: string, spacing: number, reverse: boolean) {\n  if (channel === 'x') {\n    return {\n      x2: ref.bin(fieldDef, scaleName, 'start', reverse ? 0 : spacing),\n      x: ref.bin(fieldDef, scaleName, 'end', reverse ? spacing : 0)\n    };\n  } else {\n    return {\n      y2: ref.bin(fieldDef, scaleName, 'start', reverse ? spacing : 0),\n      y: ref.bin(fieldDef, scaleName, 'end', reverse ? 0 : spacing)\n    };\n  }\n}\n\n\n/**\n * Return mixins for point (non-band) position channels.\n */\nexport function pointPosition(channel: 'x'|'y', model: UnitModel, defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax', vgChannel?: 'x'|'y'|'xc'|'yc') {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, mark, stack} = model;\n\n  const channelDef = encoding[channel];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n\n  const valueRef = !channelDef && (encoding.latitude || encoding.longitude) ?\n    // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n    {field: model.getName(channel)} :\n    {\n      ...ref.position(channel, encoding[channel], scaleName, scale, stack,\n        ref.getDefaultRef(defaultRef, channel, scaleName, scale, mark)\n      ),\n     ...(offset ? {offset}: {})\n    };\n\n  return {\n    [vgChannel || channel]: valueRef\n  };\n}\n\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nexport function pointPosition2(model: UnitModel, defaultRef: 'zeroOrMin' | 'zeroOrMax', channel: 'x2' | 'y2') {\n  const {encoding, mark, stack} = model;\n\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n  const valueRef = !channelDef && (encoding.latitude || encoding.longitude) ?\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    {field: model.getName(channel)}:\n    {\n      ...ref.position2(channel, channelDef, encoding[channel], scaleName, scale, stack,\n        ref.getDefaultRef(defaultRef, baseChannel, scaleName, scale, mark)\n      ),\n      ...(offset ? {offset} : {})\n    };\n\n  return {[channel]: valueRef};\n}\n"]}