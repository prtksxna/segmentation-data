{"version":3,"file":"split.js","sourceRoot":"","sources":["../../../src/compile/split.ts"],"names":[],"mappings":"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","sourcesContent":["import * as log from '../log';\nimport {duplicate, keys, stringify} from '../util';\n\n\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\nexport class Split<T extends object> {\n  constructor(\n    public readonly explicit: Partial<T> = {},\n    public readonly implicit: Partial<T> = {}\n  ) {}\n\n  public clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  public combine(): Partial<T> {\n    // FIXME remove \"as any\".\n    // Add \"as any\" to avoid an error \"Spread types may only be created from object types\".\n    return {\n      ...this.explicit as any, // Explicit properties comes first\n      ...this.implicit as any\n    };\n  }\n\n  public get<K extends keyof T>(key: K): T[K] {\n    // Explicit has higher precedence\n    return this.explicit[key] !== undefined ? this.explicit[key] : this.implicit[key];\n  }\n\n  public getWithExplicit<K extends keyof T>(key: K): Explicit<T[K]> {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {explicit: true, value: this.explicit[key]};\n    } else if (this.implicit[key] !== undefined) {\n      return {explicit: false, value: this.implicit[key]};\n    }\n    return {explicit: false, value: undefined};\n  }\n\n  public setWithExplicit<K extends keyof T>(key: K, value: Explicit<T[K]>) {\n    if (value.value !== undefined) {\n      this.set(key, value.value, value.explicit);\n    }\n  }\n\n  public set<K extends keyof T>(key: K, value: T[K], explicit: boolean) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  public copyKeyFromSplit<S extends T>(key: keyof T, s: Split<S>) {\n    // Explicit has higher precedence\n    if (s.explicit[key] !== undefined) {\n      this.set(key, s.explicit[key], true);\n    } else if (s.implicit[key] !== undefined) {\n      this.set(key, s.implicit[key], false);\n    }\n  }\n  public copyKeyFromObject<S extends Partial<T>>(key: keyof T, s: S) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  public copyAll(other: Split<T>) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\n\nexport interface Explicit<T> {\n  explicit: boolean;\n  value: T;\n}\n\n\nexport function makeExplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: true,\n    value\n  };\n}\n\nexport function makeImplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: false,\n    value\n  };\n}\n\nexport function tieBreakByComparing<S, T>(compare: (v1: T, v2: T) => number) {\n  return (v1: Explicit<T>, v2: Explicit<T>, property: keyof S | never, propertyOf: string | number | symbol): Explicit<T> => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker<S, T>(v1, v2, property, propertyOf);\n  };\n}\n\nexport function defaultTieBreaker<S, T>(v1: Explicit<T>, v2: Explicit<T>, property: keyof S, propertyOf: string | number | symbol) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\n\nexport function mergeValuesWithExplicit<S, T>(\n    v1: Explicit<T>, v2: Explicit<T>,\n    property: keyof S,\n    propertyOf: 'scale' | 'axis' | 'legend' | '',\n    tieBreaker: (v1: Explicit<T>, v2: Explicit<T>, property: keyof S, propertyOf: string) => Explicit<T> = defaultTieBreaker\n  ) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (stringify(v1.value) === stringify(v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}\n"]}