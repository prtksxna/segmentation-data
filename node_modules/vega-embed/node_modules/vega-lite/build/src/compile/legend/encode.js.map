{"version":3,"file":"encode.js","sourceRoot":"","sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\n\nimport {Channel, COLOR, NonPositionScaleChannel, OPACITY, SHAPE} from '../../channel';\nimport {\n  Conditional,\n  FieldDef,\n  FieldDefWithCondition,\n  hasConditionalValueDef,\n  isTimeFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  ValueDef,\n  ValueDefWithCondition,\n} from '../../fielddef';\nimport {AREA, BAR, CIRCLE, FILL_STROKE_CONFIG, GEOSHAPE, LINE, POINT, SQUARE, TEXT, TICK} from '../../mark';\nimport {ScaleType} from '../../scale';\nimport {keys} from '../../util';\nimport {LegendType, VgEncodeEntry} from '../../vega.schema';\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport * as mixins from '../mark/mixins';\nimport {UnitModel} from '../unit';\n\nexport function symbols(fieldDef: FieldDef<string>, symbolsSpec: any, model: UnitModel, channel: Channel, type: LegendType): VgEncodeEntry {\n  if (type === 'gradient') {\n    return undefined;\n  }\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model)\n  };\n\n  switch (model.mark) {\n    case BAR:\n    case TICK:\n    case TEXT:\n      out.shape = {value: 'square'};\n      break;\n    case CIRCLE:\n    case SQUARE:\n      out.shape = {value: model.mark};\n      break;\n    case POINT:\n    case LINE:\n    case GEOSHAPE:\n    case AREA:\n      // use default circle\n      break;\n  }\n\n  const {markDef, encoding} = model;\n  const filled = markDef.filled;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, remove fill field\n        delete out.fill;\n      } else if (isArray(out.fill)) {\n        const fill = getFirstConditionValue(encoding.fill || encoding.color) || markDef.fill || (filled && markDef.color);\n        if (fill) {\n          out.fill = {value: fill};\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstConditionValue(encoding.stroke || encoding.color) || markDef.stroke || (!filled && markDef.color);\n        if (stroke) {\n          out.stroke = {value: stroke};\n        }\n      }\n    }\n  }\n\n  if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke) {\n    // for non color channel's legend, we need to override symbol stroke config from Vega config\n    out.stroke = {value: 'transparent'};\n  }\n\n  if (channel !== SHAPE) {\n    const shape = getFirstConditionValue(encoding.shape) || markDef.shape;\n    if (shape) {\n      out.shape = {value: shape};\n    }\n  }\n\n  if (channel !== OPACITY) {\n    const opacity = getMaxValue(encoding.opacity) || markDef.opacity;\n    if (opacity) { // only apply opacity if it is neither zero or undefined\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function gradient(fieldDef: FieldDef<string>, gradientSpec: any, model: UnitModel, channel: Channel, type: LegendType) {\n  let out: any = {};\n\n  if (type === 'gradient') {\n    const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n    if (opacity) { // only apply opacity if it is neither zero or undefined\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...gradientSpec};\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function labels(fieldDef: FieldDef<string>, labelsSpec: any, model: UnitModel, channel: NonPositionScaleChannel, type: LegendType) {\n  const legend = model.legend(channel);\n  const config = model.config;\n\n  let out: any = {};\n\n  if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat, isUTCScale);\n    labelsSpec = {\n      ...(expr ? {text: {signal: expr}} : {}),\n      ...labelsSpec,\n    };\n  }\n\n  out = {...out, ...labelsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nfunction getMaxValue(channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>) {\n  return getConditionValue(channelDef,\n    (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any)\n  );\n}\n\nfunction getFirstConditionValue(channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>) {\n  return getConditionValue(channelDef,\n    (v: number, conditionalDef) => v !== undefined ? v : conditionalDef.value\n  );\n}\n\nfunction getConditionValue<T>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>,\n  reducer: (val: T, conditionalDef: Conditional<ValueDef>) => T\n): T {\n\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition])\n      .reduce(reducer, channelDef.value as any);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n"]}