{"version":3,"file":"interval.js","sourceRoot":"","sources":["../../../../src/compile/selection/interval.ts"],"names":[],"mappings":";AAAA,OAAO,EAAC,WAAW,EAAC,MAAM,WAAW,CAAC;AACtC,OAAO,EAAC,CAAC,EAAE,CAAC,EAAC,MAAM,eAAe,CAAC;AACnC,OAAO,EAAC,IAAI,EAAC,MAAM,WAAW,CAAC;AAC/B,OAAO,EAAC,mBAAmB,EAAE,UAAU,EAAC,MAAM,aAAa,CAAC;AAC5D,OAAO,EAAC,IAAI,EAAC,MAAM,YAAY,CAAC;AAGhC,OAAO,EACL,iBAAiB,EACjB,qBAAqB,EAGrB,KAAK,EACL,KAAK,EACL,QAAQ,GACT,MAAM,aAAa,CAAC;AACrB,OAAO,MAAM,MAAM,qBAAqB,CAAC;AAEzC,MAAM,CAAC,IAAM,KAAK,GAAG,QAAQ,CAAC;AAC9B,MAAM,CAAC,IAAM,aAAa,GAAG,gBAAgB,CAAC;AAE9C,IAAM,QAAQ,GAAqB;IACjC,SAAS,EAAE,YAAY;IACvB,WAAW,EAAE,kBAAkB;IAE/B,OAAO,EAAE,UAAS,KAAK,EAAE,OAAO;QAC9B,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QAC1B,IAAM,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACtC,IAAM,OAAO,GAAU,EAAE,CAAC;QAC1B,IAAM,SAAS,GAAU,EAAE,CAAC;QAC5B,IAAM,aAAa,GAAa,EAAE,CAAC;QACnC,IAAM,aAAa,GAAU,EAAE,CAAC;QAEhC,IAAI,OAAO,CAAC,SAAS,IAAI,CAAC,SAAS,EAAE;YACnC,IAAM,YAAU,GAAG,6CAA2C,WAAW,CAAC,IAAI,GAAG,KAAK,CAAG,CAAC;YAC1F,MAAM,CAAC,OAAO,EAAE,UAAS,CAAQ,EAAE,GAAkB;gBACnD,IAAM,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,EAAE,CAAC,CAAC;gBACtE,IAAI,OAAO,CAAC,OAAO,CAAC,YAAU,CAAC,GAAG,CAAC,EAAE;oBACnC,OAAO,CAAC,IAAI,CAAC,YAAU,CAAC,CAAC;iBAC1B;YACH,CAAC,CAAC,CAAC;SACJ;QAED,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,UAAS,CAAC;YAChC,IAAM,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC;YAC1B,IAAI,OAAO,KAAK,CAAC,IAAI,OAAO,KAAK,CAAC,EAAE;gBAClC,IAAI,CAAC,6DAA6D,CAAC,CAAC;gBACpE,OAAO;aACR;YAED,IAAM,EAAE,GAAG,cAAc,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;YACnD,IAAM,KAAK,GAAG,iBAAiB,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;YAC1D,IAAM,KAAK,GAAG,iBAAiB,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;YAC5D,IAAM,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;YACvD,IAAM,SAAS,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YAC/D,IAAM,KAAK,GAAG,mBAAmB,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YAExD,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;YAChC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC1B,SAAS,CAAC,IAAI,CAAC,gBAAc,WAAW,CAAC,OAAO,CAAC,OAAI;iBACnD,YAAU,WAAW,CAAC,CAAC,CAAC,KAAK,CAAC,kBAAa,KAAK,MAAG,CAAA,CAAC,CAAC;YAEvD,aAAa,CAAC,IAAI,CAAC;gBACjB,SAAS,EAAE,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC;gBACnC,IAAI,EAAE,eAAa,KAAK,UAAO;qBAC7B,MAAI,KAAK,eAAU,QAAQ,UAAK,KAAK,iBAAY,KAAK,GAAG,KAAK,YAAS,CAAA;qBAClE,KAAK,eAAU,QAAQ,UAAK,KAAK,iBAAY,KAAK,GAAG,KAAK,UAAO,CAAA;aACzE,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,sEAAsE;QACtE,uDAAuD;QACvD,IAAI,CAAC,SAAS,EAAE;YACd,OAAO,CAAC,IAAI,CAAC;gBACX,IAAI,EAAE,IAAI,GAAG,aAAa;gBAC1B,MAAM,EAAE,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,EAAN,CAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;qBACnD,SAAM,IAAI,GAAG,aAAa,WAAO,CAAA;aACpC,CAAC,CAAC;SACJ;QAED,+EAA+E;QAC/E,2EAA2E;QAC3E,kFAAkF;QAClF,OAAO,OAAO,CAAC,MAAM,CAAC;YACpB,IAAI,EAAE,IAAI,GAAG,KAAK;YAClB,EAAE,EAAE,CAAC;oBACH,MAAM,EAAE,aAAa,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,EAAC,MAAM,EAAE,CAAC,EAAC,CAAC,EAAb,CAAa,CAAC;oBAC/C,MAAM,EAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC;yBAChC,eAAa,QAAQ,CAAC,KAAK,CAAC,sBAAiB,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,cAAW,CAAA;iBAC/E,CAAC;SACH,CAAC,CAAC;IACL,CAAC;IAED,UAAU,EAAE,UAAS,KAAK,EAAE,OAAO;QACjC,IAAM,GAAG,GAAG,OAAO,CAAC,IAAI,GAAG,KAAK,CAAC;QACjC,OAAO,GAAG,GAAG,IAAI;YACf,CAAC,OAAO,CAAC,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,YAAU,QAAQ,CAAC,KAAK,CAAC,MAAG,CAAC,CAAC;IAC3E,CAAC;IAED,KAAK,EAAE,UAAS,KAAK,EAAE,OAAO,EAAE,KAAK;QACnC,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QACpB,IAAA,mCAAyC,EAAxC,UAAE,EAAE,UAAE,CAAmC;QAChD,IAAM,KAAK,GAAG,UAAQ,WAAW,CAAC,OAAO,CAAC,IAAI,GAAG,KAAK,CAAC,MAAG,CAAC;QAE3D,iDAAiD;QACjD,IAAI,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YACvB,OAAO,KAAK,CAAC;SACd;QAED,IAAM,MAAM,GAAQ;YAClB,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC,EAAC,MAAM,EAAK,IAAI,UAAO,EAAC,CAAC,CAAC,CAAC,EAAC,KAAK,EAAE,CAAC,EAAC;YACtD,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC,EAAC,MAAM,EAAK,IAAI,UAAO,EAAC,CAAC,CAAC,CAAC,EAAC,KAAK,EAAE,CAAC,EAAC;YACtD,EAAE,EAAE,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC,EAAC,MAAM,EAAK,IAAI,UAAO,EAAC,CAAC,CAAC,CAAC,EAAC,KAAK,EAAE,EAAC,KAAK,EAAE,OAAO,EAAC,EAAC;YACtE,EAAE,EAAE,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC,EAAC,MAAM,EAAK,IAAI,UAAO,EAAC,CAAC,CAAC,CAAC,EAAC,KAAK,EAAE,EAAC,KAAK,EAAE,QAAQ,EAAC,EAAC;SACxE,CAAC;QAEF,uEAAuE;QACvE,wEAAwE;QACxE,2EAA2E;QAC3E,iDAAiD;QACjD,IAAI,OAAO,CAAC,OAAO,KAAK,QAAQ,EAAE;YAChC,KAAkB,UAAY,EAAZ,KAAA,IAAI,CAAC,MAAM,CAAC,EAAZ,cAAY,EAAZ,IAAY,EAAE;gBAA3B,IAAM,GAAG,SAAA;gBACZ,MAAM,CAAC,GAAG,CAAC,GAAG,oBACZ,IAAI,EAAK,KAAK,mBAAc,KAAK,qBAAgB,QAAQ,CAAC,KAAK,CAAG,IAC/D,MAAM,CAAC,GAAG,CAAC,GACb,EAAC,KAAK,EAAE,CAAC,EAAC,CAAC,CAAC;aAChB;SACF;QAED,yEAAyE;QACzE,4EAA4E;QAC5E,iDAAiD;QACjD,IAAM,iBAA6C,EAA5C,cAAI,EAAE,4BAAW,EAAE,oDAAyB,CAAC;QACpD,IAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,CAAC;YAC1C,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;oBACR,IAAI,EAAE;wBACJ,EAAE,KAAK,IAAI,IAAO,IAAI,kBAAa,IAAI,UAAO;wBAC9C,EAAE,IAAI,IAAI,IAAO,IAAI,kBAAa,IAAI,UAAO;qBAC9C,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,EAAD,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;oBAC7B,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;iBACjB,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;YAClB,OAAO,GAAG,CAAC;QACb,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,OAAO,CAAC;gBACN,IAAI,EAAE,IAAI,GAAG,KAAK,GAAG,KAAK;gBAC1B,IAAI,EAAE,MAAM;gBACZ,IAAI,EAAE,IAAI;gBACV,MAAM,EAAE;oBACN,KAAK,EAAE;wBACL,IAAI,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC;wBACnB,WAAW,EAAE,EAAC,KAAK,EAAE,WAAW,EAAC;qBAClC;oBACD,MAAM,EAAE,MAAM;iBACf;aACK,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE;YACtB,IAAI,EAAE,IAAI,GAAG,KAAK;YAClB,IAAI,EAAE,MAAM;YACZ,IAAI,EAAE,IAAI;YACV,MAAM,EAAE;gBACN,KAAK,EAAE;oBACL,IAAI,EAAE,EAAC,KAAK,EAAE,aAAa,EAAC;iBAC7B;gBACD,MAAM,uBAAM,MAAM,EAAK,QAAQ,CAAC;aACjC;SACF,CAAC,CAAC;IACL,CAAC;CACF,CAAC;AACF,eAAe,QAAQ,CAAC;AAExB;;GAEG;AACH,wBAAwB,KAAgB,EAAE,OAA2B,EAAE,OAAgB;IACrF,IAAM,KAAK,GAAG,iBAAiB,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC5D,IAAM,KAAK,GAAG,iBAAiB,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IAC1D,IAAM,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACtC,IAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAC3C,IAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;IACxC,IAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;IAC/C,IAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACxD,IAAM,IAAI,GAAG,KAAK,CAAC,gBAAgB,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;IAC/E,IAAM,KAAK,GAAM,OAAO,WAAQ,CAAC;IAEjC,IAAM,EAAE,GAAG,MAAM,CAAC,OAAO,EAAE,UAAS,GAAU,EAAE,GAAkB;QAChE,OAAO,GAAG,CAAC,MAAM,CACf,EAAC,MAAM,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,MAAI,KAAK,UAAK,KAAK,MAAG,EAAC,EAAY,cAAc;QAClF,EAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,MAAI,KAAK,mBAAc,KAAK,aAAQ,IAAI,OAAI,EAAC,CAAC,YAAY;SACjF,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,iEAAiE;IACjE,uEAAuE;IACvE,+DAA+D;IAC/D,EAAE,CAAC,IAAI,CAAC;QACN,MAAM,EAAE,EAAC,MAAM,EAAE,OAAO,CAAC,IAAI,GAAG,aAAa,EAAC;QAC9C,MAAM,EAAE,mBAAmB,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;YAChE,YAAU,QAAQ,UAAK,KAAK,oBAAe,QAAQ,UAAK,KAAK,UAAO,CAAC,CAAC,CAAC,QAAQ;KAClF,CAAC,CAAC;IAEH,OAAO,SAAS,CAAC,CAAC,CAAC,CAAC,EAAC,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;SAC/B,EAAE;YACD,IAAI,EAAE,KAAK;YACX,EAAE,EAAE,CAAC,EAAC,MAAM,EAAE,EAAC,MAAM,EAAE,KAAK,EAAC,EAAE,MAAM,EAAK,KAAK,gBAAW,KAAK,4BAAuB,QAAQ,UAAK,KAAK,MAAG,EAAC,CAAC;SAC9G,CAAC,CAAC;AACL,CAAC;AAED,gBAAgB,OAA2B,EAAE,EAAY;IACvD,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,UAAS,EAAS,EAAE,GAAkB;QACjE,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE;YAChB,IAAI,CAAI,GAAG,4DAAyD,CAAC,CAAC;YACtE,OAAO,EAAE,CAAC;SACX;QACD,OAAO,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC;IACrB,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC","sourcesContent":["import {stringValue} from 'vega-util';\nimport {X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {hasContinuousDomain, isBinScale} from '../../scale';\nimport {keys} from '../../util';\nimport {VgEventStream} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {\n  channelSignalName,\n  positionalProjections,\n  SelectionCompiler,\n  SelectionComponent,\n  STORE,\n  TUPLE,\n  unitName,\n} from './selection';\nimport scales from './transforms/scales';\n\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\n\nconst interval:SelectionCompiler = {\n  predicate: 'vlInterval',\n  scaleDomain: 'vlIntervalDomain',\n\n  signals: function(model, selCmpt) {\n    const name = selCmpt.name;\n    const hasScales = scales.has(selCmpt);\n    const signals: any[] = [];\n    const intervals: any[] = [];\n    const tupleTriggers: string[] = [];\n    const scaleTriggers: any[] = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n      events(selCmpt, function(_: any[], evt: VgEventStream) {\n        const filters = evt.between[0].filter || (evt.between[0].filter = []);\n        if (filters.indexOf(filterExpr) < 0) {\n          filters.push(filterExpr);\n        }\n      });\n    }\n\n    selCmpt.project.forEach(function(p) {\n      const channel = p.channel;\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      const cs = channelSignals(model, selCmpt, channel);\n      const dname = channelSignalName(selCmpt, channel, 'data');\n      const vname = channelSignalName(selCmpt, channel, 'visual');\n      const scaleStr = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n\n      signals.push.apply(signals, cs);\n      tupleTriggers.push(dname);\n      intervals.push(`{encoding: ${stringValue(channel)}, ` +\n        `field: ${stringValue(p.field)}, extent: ${dname}}`);\n\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr: `(!isArray(${dname}) || ` +\n          `(${toNum}invert(${scaleStr}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n            `${toNum}invert(${scaleStr}, ${vname})[1] === ${toNum}${dname}[1]))`\n      });\n    });\n\n    // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n    if (!hasScales) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        update: scaleTriggers.map((t) => t.expr).join(' && ') +\n          ` ? ${name + SCALE_TRIGGER} : {}`\n      });\n    }\n\n    // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n    return signals.concat({\n      name: name + TUPLE,\n      on: [{\n        events: tupleTriggers.map((t) => ({signal: t})),\n        update: tupleTriggers.join(' && ') +\n          ` ? {unit: ${unitName(model)}, intervals: [${intervals.join(', ')}]} : null`\n      }]\n    });\n  },\n\n  modifyExpr: function(model, selCmpt) {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' +\n      (selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`);\n  },\n\n  marks: function(model, selCmpt, marks) {\n    const name = selCmpt.name;\n    const {xi, yi} = positionalProjections(selCmpt);\n    const store = `data(${stringValue(selCmpt.name + STORE)})`;\n\n    // Do not add a brush if we're binding to scales.\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    const update: any = {\n      x: xi !== null ? {signal: `${name}_x[0]`} : {value: 0},\n      y: yi !== null ? {signal: `${name}_y[0]`} : {value: 0},\n      x2: xi !== null ? {signal: `${name}_x[1]`} : {field: {group: 'width'}},\n      y2: yi !== null ? {signal: `${name}_y[1]`} : {field: {group: 'height'}}\n    };\n\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [{\n          test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,\n          ...update[key]\n        }, {value: 0}];\n      }\n    }\n\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    const {fill, fillOpacity, ...stroke} = selCmpt.mark;\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [{\n        test: [\n          xi !== null && `${name}_x[0] !== ${name}_x[1]`,\n          yi != null && `${name}_y[0] !== ${name}_y[1]`,\n        ].filter(x => x).join(' && '),\n        value: stroke[k]\n      }, {value: null}];\n      return def;\n    }, {});\n\n    return [{\n      name: name + BRUSH + '_bg',\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {value: fill},\n          fillOpacity: {value: fillOpacity}\n        },\n        update: update\n      }\n    } as any].concat(marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {value: 'transparent'}\n        },\n        update: {...update, ...vgStroke}\n      }\n    });\n  }\n};\nexport default interval;\n\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(model: UnitModel, selCmpt: SelectionComponent, channel: 'x'|'y'): any {\n  const vname = channelSignalName(selCmpt, channel, 'visual');\n  const dname = channelSignalName(selCmpt, channel, 'data');\n  const hasScales = scales.has(selCmpt);\n  const scaleName = model.scaleName(channel);\n  const scaleStr = stringValue(scaleName);\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n\n  const on = events(selCmpt, function(def: any[], evt: VgEventStream) {\n    return def.concat(\n      {events: evt.between[0], update: `[${coord}, ${coord}]`},           // Brush Start\n      {events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]`} // Brush End\n    );\n  });\n\n  // React to pan/zooms of continuous scales. Non-continuous scales\n  // (bin-linear, band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n  on.push({\n    events: {signal: selCmpt.name + SCALE_TRIGGER},\n    update: hasContinuousDomain(scaleType) && !isBinScale(scaleType) ?\n      `[scale(${scaleStr}, ${dname}[0]), scale(${scaleStr}, ${dname}[1])]` : `[0, 0]`\n  });\n\n  return hasScales ? [{name: dname, on: []}] : [{\n    name: vname, value: [], on: on\n  }, {\n    name: dname,\n    on: [{events: {signal: vname}, update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleStr}, ${vname})`}]\n  }];\n}\n\nfunction events(selCmpt: SelectionComponent, cb: Function) {\n  return selCmpt.events.reduce(function(on: any[], evt: VgEventStream) {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections`);\n      return on;\n    }\n    return cb(on, evt);\n  }, []);\n}\n"]}