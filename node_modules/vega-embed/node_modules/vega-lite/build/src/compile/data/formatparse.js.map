{"version":3,"file":"formatparse.js","sourceRoot":"","sources":["../../../../src/compile/data/formatparse.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNumber, isString, toSet} from 'vega-util';\nimport {AncestorParse} from '.';\nimport {isCountingAggregateOp} from '../../aggregate';\nimport {DateTime, isDateTime} from '../../datetime';\nimport {isNumberFieldDef, isScaleFieldDef, isTimeFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {forEachLeaf} from '../../logical';\nimport {isFieldEqualPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate} from '../../predicate';\nimport {isSortField} from '../../sort';\nimport {FilterTransform} from '../../transform';\nimport {accessPathDepth, accessPathWithDatum, Dict, duplicate, keys, removePathFromField, StringSet} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {Split} from '../split';\nimport {DataFlowNode} from './dataflow';\n\n\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field: string, parse: string): string {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.indexOf('date:') === 0) {\n    const specifier = parse.slice(5, parse.length);\n    return `timeParse(${f},${specifier})`;\n  } else if (parse.indexOf('utc:') === 0) {\n    const specifier = parse.slice(4, parse.length);\n    return `utcParse(${f},${specifier})`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport class ParseNode extends DataFlowNode {\n  private _parse: Dict<string>;\n\n  public clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  constructor(parent: DataFlowNode, parse: Dict<string>) {\n    super(parent);\n\n    this._parse = parse;\n  }\n\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  public static makeExplicit(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (data && data.format && data.format.parse) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n\n  public static makeImplicitFromFilterTransform(parent: DataFlowNode, transform: FilterTransform, ancestorParse: AncestorParse) {\n    const parse = {};\n    forEachLeaf(transform.filter, filter => {\n      if (isFieldPredicate(filter)) {\n        // Automatically add a parse node for filters with filter objects\n        let val: string | number | boolean | DateTime = null;\n\n        // For EqualFilter, just use the equal property.\n        // For RangeFilter and OneOfFilter, all array members should have\n        // the same type, so we only use the first one.\n        if (isFieldEqualPredicate(filter)) {\n          val = filter.equal;\n        } else if (isFieldRangePredicate(filter)) {\n          val = filter.range[0];\n        } else if (isFieldOneOfPredicate(filter)) {\n          val = (filter.oneOf || filter['in'])[0];\n        } // else -- for filter expression, we can't infer anything\n        if (val) {\n          if (isDateTime(val)) {\n            parse[filter.field] = 'date';\n          } else if (isNumber(val)) {\n            parse[filter.field] = 'number';\n          } else if (isString(val)) {\n            parse[filter.field] = 'string';\n          }\n        }\n\n        if (filter.timeUnit) {\n          parse[filter.field] = 'date';\n        }\n      }\n    });\n\n    if (keys(parse).length === 0) {\n      return null;\n    }\n\n    return this.makeWithAncestors(parent, {}, parse, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n   */\n  public static makeImplicitFromEncoding(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    const implicit = {};\n\n    if (isUnitModel(model) || isFacetModel(model)) {\n      // Parse encoded fields\n      model.forEachFieldDef(fieldDef => {\n        if (isTimeFieldDef(fieldDef)) {\n          implicit[fieldDef.field] = 'date';\n        } else if (isNumberFieldDef(fieldDef)) {\n          if (!isCountingAggregateOp(fieldDef.aggregate)) {\n            implicit[fieldDef.field] = 'number';\n          }\n        } else if (accessPathDepth(fieldDef.field) > 1) {\n          // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n          // (Parsing numbers / dates already flattens numeric and temporal fields.)\n          if (!(fieldDef.field in implicit)) {\n            implicit[fieldDef.field] = 'flatten';\n          }\n        } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n          // Flatten fields that we sort by but that are not otherwise flattened.\n          if (!(fieldDef.sort.field in implicit)) {\n            implicit[fieldDef.sort.field] = 'flatten';\n          }\n        }\n      });\n    }\n\n    return this.makeWithAncestors(parent, {}, implicit, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  private static makeWithAncestors(parent: DataFlowNode, explicit: Dict<string>, implicit: Dict<string>, ancestorParse: AncestorParse) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit);\n\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n\n    // copy only non-null parses\n    const p = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  public get parse() {\n    return this._parse;\n  }\n\n  public merge(other: ParseNode) {\n    this._parse = {...this._parse, ...other.parse};\n    other.remove();\n  }\n\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  public assembleFormatParse() {\n    const formatParse = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n\n  // format parse depends and produces all fields in its parse\n  public producedFields(): StringSet {\n    return toSet(keys(this._parse));\n  }\n\n  public dependentFields(): StringSet {\n    return toSet(keys(this._parse));\n  }\n\n  public assembleTransforms(onlyNested = false): VgFormulaTransform[] {\n    return keys(this._parse)\n      .filter(field => onlyNested ? accessPathDepth(field) > 1 : true)\n      .map(field => {\n        const expr = parseExpression(field, this._parse[field]);\n        if (!expr) {\n          return null;\n        }\n\n        const formula: VgFormulaTransform = {\n          type: 'formula',\n          expr,\n          as: removePathFromField(field)  // Vega output is always flattened\n        };\n        return formula;\n      }).filter(t => t !== null);\n  }\n}\n"]}