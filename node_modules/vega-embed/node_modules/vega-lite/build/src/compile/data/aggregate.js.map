{"version":3,"file":"aggregate.js","sourceRoot":"","sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\n\nimport {Channel, isScaleChannel} from '../../channel';\nimport {FieldDef, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, differ, duplicate, keys, StringSet} from '../../util';\nimport {VgAggregateTransform} from '../../vega.schema';\nimport {binRequiresRange} from '../common';\nimport {UnitModel} from './../unit';\nimport {DataFlowNode} from './dataflow';\n\nfunction addDimension(dims: {[field: string]: boolean}, channel: Channel, fieldDef: FieldDef<string>) {\n  if (fieldDef.bin) {\n    dims[vgField(fieldDef, {})] = true;\n    dims[vgField(fieldDef, {binSuffix: 'end'})] = true;\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims[vgField(fieldDef, {binSuffix: 'range'})] = true;\n    }\n  } else {\n    dims[vgField(fieldDef)] = true;\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Dict<Dict<string>>, childMeasures: Dict<Dict<string>>) {\n  for (const f in childMeasures) {\n    if (childMeasures.hasOwnProperty(f)) {\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      const ops = childMeasures[f];\n      for (const op in ops) {\n        if (ops.hasOwnProperty(op)) {\n          if (f in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[f][op] = ops[op];\n          } else {\n            parentMeasures[f] = {op: ops[op]};\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  public clone() {\n    return new AggregateNode(null, {...this.dimensions}, duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent: DataFlowNode, private dimensions: StringSet, private measures: Dict<{[key in AggregateOp]?: string}>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas = {};\n    const dims = {};\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = vgField(fieldDef);\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][aggregate] = vgField(fieldDef);\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field]['min'] = vgField({field, aggregate: 'min'});\n            meas[field]['max'] = vgField({field, aggregate: 'max'});\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef);\n      }\n    });\n\n    if ((keys(dims).length + keys(meas).length) === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = {};\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = as || vgField(s);\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][op] = as || vgField(s);\n        }\n      }\n    }\n\n    for (const s of t.groupby || []) {\n      dims[s] = true;\n    }\n\n    if ((keys(dims).length + keys(meas).length) === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode) {\n    if (!differ(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      other.remove();\n    } else {\n      log.debug('different dimensions, cannot merge');\n    }\n  }\n\n  public addDimensions(fields: string[]) {\n    fields.forEach(f => this.dimensions[f] = true);\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    keys(this.dimensions).forEach(f => out[f] = true);\n    keys(this.measures).forEach(m => out[m] = true);\n\n    return out;\n  }\n\n  public producedFields() {\n    const out = {};\n\n    keys(this.measures).forEach(field => {\n      keys(this.measures[field]).forEach(op => {\n        out[`${op}_${field}`] = true;\n      });\n    });\n\n    return out;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        as.push(this.measures[field][op]);\n        ops.push(op);\n        fields.push(field);\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: keys(this.dimensions),\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n"]}