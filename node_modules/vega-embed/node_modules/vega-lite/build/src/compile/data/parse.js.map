{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/data/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {MAIN, RAW} from '../../data';\nimport * as log from '../../log';\nimport {isAggregate, isBin, isCalculate, isFilter, isLookup, isStack, isTimeUnit, isWindow} from '../../transform';\nimport {Dict, keys} from '../../util';\nimport {isFacetModel, isLayerModel, isUnitModel, Model} from '../model';\nimport {requiresSelectionId} from '../selection/selection';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FilterInvalidNode} from './filterinvalid';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {IdentifierNode} from './identifier';\nimport {AncestorParse, DataComponent} from './index';\nimport {LookupNode} from './lookup';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nfunction parseRoot(model: Model, sources: Dict<SourceNode>): DataFlowNode {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n    const source = new SourceNode(model.data);\n    const hash = source.hash();\n    if (hash in sources) {\n      // use a reference if we already have a source\n      return sources[hash];\n    } else {\n      // otherwise add a new one\n      sources[hash] = source;\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;\n  }\n}\n\n\n/**\n * Parses a transforms array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head: DataFlowNode, model: Model, ancestorParse: AncestorParse): DataFlowNode {\n  let lookupCounter = 0;\n\n  model.transforms.forEach(t => {\n    if (isCalculate(t)) {\n      head = new CalculateNode(head, t);\n      ancestorParse.set(t.as, 'derived', false);\n    } else if (isFilter(t)) {\n      head = ParseNode.makeImplicitFromFilterTransform(head, t, ancestorParse) || head;\n\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      const bin = head = BinNode.makeFromTransform(head, t, model);\n\n      for (const field of keys(bin.producedFields())) {\n        ancestorParse.set(field, 'number', false);\n      }\n\n    } else if (isTimeUnit(t)) {\n      head = TimeUnitNode.makeFromTransform(head, t);\n\n      ancestorParse.set(t.as, 'date', false);\n    } else if (isAggregate(t)) {\n      const agg = head = AggregateNode.makeFromTransform(head, t);\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n\n      for (const field of keys(agg.producedFields())) {\n        ancestorParse.set(field, 'derived', false);\n      }\n    } else if (isLookup(t)) {\n      const lookup = head = LookupNode.make(head, model, t, lookupCounter++);\n\n      for (const field of keys(lookup.producedFields())) {\n        ancestorParse.set(field, 'derived', false);\n      }\n    } else if (isWindow(t)) {\n      const window = head = new WindowTransformNode(head, t);\n\n      for (const field of keys(window.producedFields())) {\n        ancestorParse.set(field, 'derived', false);\n      }\n    } else if (isStack(t)) {\n      const stack = head = StackNode.makeFromTransform(head, t);\n\n      for (const field of keys(stack.producedFields())) {\n        ancestorParse.set(field, 'derived', false);\n      }\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      return;\n    }\n  });\n\n  return head;\n}\n\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model: Model): DataComponent {\n  let head = parseRoot(model, model.component.data.sources);\n\n  const {outputNodes, outputNodeRefCounts} = model.component.data;\n  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n\n  // format.parse: null means disable parsing\n  if (model.data && model.data.format && model.data.format.parse === null) {\n    ancestorParse.parseNothing = true;\n  }\n\n  head = ParseNode.makeExplicit(head, model, ancestorParse) || head;\n\n  // Default discrete selections require an identifier transform to\n  // uniquely identify data points as the _id field is volatile. Add\n  // this transform at the head of our pipeline such that the identifier\n  // field is available for all subsequent datasets. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n  if (requiresSelectionId(model) && (isUnitModel(model) || isLayerModel(model))) {\n    head = new IdentifierNode(head);\n  }\n\n  // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  }\n\n  head = ParseNode.makeImplicitFromEncoding(head, model, ancestorParse) || head;\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n\n    if (!parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n\n    head = TimeUnitNode.makeFromEncoding(head, model) || head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  }\n\n  // add an output node pre aggregation\n  const rawName = model.getName(RAW);\n  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n\n    head = StackNode.makeFromEncoding(head, model) || head;\n  }\n\n  if (isUnitModel(model)) {\n    head = FilterInvalidNode.make(head, model) || head;\n  }\n\n  // output node for marks\n  const mainName = model.getName(MAIN);\n  const main = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  // add facet marker\n  let facetRoot = null;\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet');\n\n    // Derive new sort index field for facet's sort array\n    head = CalculateNode.parseAllForSortIndex(head, model);\n\n    // Derive new aggregate (via window) for facet's sort field\n    // TODO: use JoinAggregate once we have it\n    // augment data source with new fields for crossed facet\n    head = WindowTransformNode.makeFromFacet(head, model.facet) || head;\n\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n    head = facetRoot;\n  }\n\n  return {\n    ...model.component.data,\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  };\n}\n"]}