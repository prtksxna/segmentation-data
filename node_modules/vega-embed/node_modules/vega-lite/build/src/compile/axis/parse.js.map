{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/axis/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {Axis, AXIS_PARTS, AxisEncoding, isAxisProperty, VG_AXIS_PROPERTIES} from '../../axis';\nimport {POSITION_SCALE_CHANNELS, PositionScaleChannel, X, Y} from '../../channel';\nimport {FieldDefBase, toFieldDefBase} from '../../fielddef';\nimport {keys} from '../../util';\nimport {AxisOrient, VgAxis, VgAxisEncode} from '../../vega.schema';\nimport {getSpecifiedOrDefaultValue, guideEncodeEntry, mergeTitle, mergeTitleComponent, mergeTitleFieldDefs, numberFormat} from '../common';\nimport {LayerModel} from '../layer';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {AxisComponent, AxisComponentIndex, AxisComponentProps} from './component';\nimport {getAxisConfig} from './config';\nimport * as encode from './encode';\nimport * as properties from './properties';\n\n\nexport function parseUnitAxis(model: UnitModel): AxisComponentIndex {\n  return POSITION_SCALE_CHANNELS.reduce(function(axis, channel) {\n    if (model.component.scales[channel] && model.axis(channel)) {\n      axis[channel] = [parseAxis(channel, model)];\n    }\n    return axis;\n  }, {} as AxisComponentIndex);\n}\n\nconst OPPOSITE_ORIENT: {[K in AxisOrient]: AxisOrient} = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'right',\n  right: 'left'\n};\n\nexport function parseLayerAxis(model: LayerModel) {\n  const {axes, resolve} = model.component;\n  const axisCount: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in AxisOrient]: number\n  } = {top: 0, bottom: 0, right: 0, left: 0};\n\n  for (const child of model.children) {\n    child.parseAxisAndHeader();\n\n    for (const channel of keys(child.component.axes)) {\n      resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n      if (resolve.axis[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n\n        if (!axes[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n          // Thus, mark axis as independent and remove the axis component.\n          resolve.axis[channel] = 'independent';\n          delete axes[channel];\n        }\n      }\n    }\n  }\n\n  // Move axes to layer's axis component and merge shared axes\n  for (const channel of [X, Y]) {\n    for (const child of model.children) {\n      if (!child.component.axes[channel]) {\n        // skip if the child does not have a particular axis\n        continue;\n      }\n\n      if (resolve.axis[channel] === 'independent') {\n        // If axes are independent, concat the axisComponent array.\n        axes[channel] = (axes[channel] || []).concat(child.component.axes[channel]);\n\n        // Automatically adjust orient\n        for (const axisComponent of child.component.axes[channel]) {\n          const {value: orient, explicit} = axisComponent.getWithExplicit('orient');\n          if (axisCount[orient] > 0 && !explicit) {\n            // Change axis orient if the number do not match\n            const oppositeOrient = OPPOSITE_ORIENT[orient];\n            if (axisCount[orient] > axisCount[oppositeOrient]) {\n              axisComponent.set('orient', oppositeOrient, false);\n            }\n          }\n          axisCount[orient]++;\n\n          // TODO(https://github.com/vega/vega-lite/issues/2634): automaticaly add extra offset?\n        }\n      }\n\n      // After merging, make sure to remove axes from child\n      delete child.component.axes[channel];\n    }\n  }\n}\n\nfunction mergeAxisComponents(mergedAxisCmpts: AxisComponent[], childAxisCmpts: AxisComponent[]): AxisComponent[] {\n  if (mergedAxisCmpts) {\n    // FIXME: this is a bit wrong once we support multiple axes\n    if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n      return undefined; // Cannot merge axis component with different number of axes.\n    }\n    const length = mergedAxisCmpts.length;\n    for (let i = 0; i < length ; i++) {\n      const merged = mergedAxisCmpts[i];\n      const child = childAxisCmpts[i];\n\n      if ((!!merged) !== (!!child)) {\n        return undefined;\n      } else if (merged && child) {\n        const mergedOrient = merged.getWithExplicit('orient');\n        const childOrient = child.getWithExplicit('orient');\n\n        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n          // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n\n          // Cannot merge due to inconsistent orient\n          return undefined;\n        } else {\n          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n        }\n      }\n    }\n  } else {\n    // For first one, return a copy of the child\n    return childAxisCmpts.map(axisComponent => axisComponent.clone());\n  }\n  return mergedAxisCmpts;\n}\n\nfunction mergeAxisComponent(merged: AxisComponent, child: AxisComponent): AxisComponent {\n  for (const prop of VG_AXIS_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<VgAxis, any>(\n      merged.getWithExplicit(prop),\n      child.getWithExplicit(prop),\n      prop, 'axis',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>) => {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'gridScale':\n            return {\n              explicit: v1.explicit, // keep the old explicit\n              value: v1.value || v2.value\n            };\n        }\n        return defaultTieBreaker<VgAxis, any>(v1, v2, prop, 'axis');\n      }\n    );\n    merged.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  return merged;\n}\n\nfunction getFieldDefTitle(model: UnitModel, channel: 'x' | 'y') {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.fieldDef(channel);\n  const fieldDef2 = model.fieldDef(channel2);\n\n  const title1 = fieldDef ? fieldDef.title : undefined;\n  const title2 = fieldDef2 ? fieldDef2.title : undefined;\n\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) { // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) { // falsy value to disable config\n    return title2;\n  }\n\n  return undefined;\n}\n\nfunction parseAxis(channel: PositionScaleChannel, model: UnitModel): AxisComponent {\n  const axis = model.axis(channel);\n\n  const axisComponent = new AxisComponent();\n\n  // 1.2. Add properties\n  VG_AXIS_PROPERTIES.forEach(function(property) {\n    const value = getProperty(property, axis, channel, model);\n    if (value !== undefined) {\n      const explicit =\n        // specified axis.values is already respected, but may get transformed.\n        property === 'values' ? !!axis.values :\n        // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n        property === 'encode' ? !!axis.encoding || !!axis.labelAngle :\n        // title can be explicit if fieldDef.title is set\n            property === 'title' && value === getFieldDefTitle(model, channel) ? true :\n        // Otherwise, things are explicit if the returned value matches the specified property\n        value === axis[property];\n\n      const configValue = getAxisConfig(property, model.config, channel, axisComponent.get('orient'), model.getScaleComponent(channel).get('type'));\n\n      // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n      if (explicit || configValue === undefined) {\n        // Do not apply implicit rule if there is a config value\n        axisComponent.set(property, value, explicit);\n      } else if (property === 'grid' && configValue) {\n        // Grid is an exception because we need to set grid = true to generate another grid axis\n        axisComponent.set(property, configValue, false);\n      }\n    }\n  });\n\n  // 2) Add guide encode definition groups\n  const axisEncoding = axis.encoding || {};\n  const axisEncode = AXIS_PARTS.reduce((e: VgAxisEncode, part) => {\n    if (!axisComponent.hasAxisPart(part)) {\n      // No need to create encode for a disabled part.\n      return e;\n    }\n\n    const axisEncodingPart = guideEncodeEntry(axisEncoding[part] || {}, model);\n\n    const value = part === 'labels' ?\n      encode.labels(model, channel, axisEncodingPart, axisComponent.get('orient')) :\n      axisEncodingPart;\n\n    if (value !== undefined && keys(value).length > 0) {\n      e[part] = {update: value};\n    }\n    return e;\n  }, {} as VgAxisEncode);\n\n  // FIXME: By having encode as one property, we won't have fine grained encode merging.\n  if (keys(axisEncode).length > 0) {\n    axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n  }\n\n  return axisComponent;\n}\n\nfunction getProperty<K extends keyof AxisComponentProps>(property: K, specifiedAxis: Axis, channel: PositionScaleChannel, model: UnitModel): AxisComponentProps[K] {\n  const fieldDef = model.fieldDef(channel);\n  switch (property) {\n    case 'scale':\n      return model.scaleName(channel);\n    case 'gridScale':\n      return properties.gridScale(model, channel);\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      return numberFormat(fieldDef, specifiedAxis.format, model.config);\n    case 'grid': {\n      const scaleType = model.getScaleComponent(channel).get('type');\n      return getSpecifiedOrDefaultValue(specifiedAxis.grid, properties.grid(scaleType, fieldDef));\n    }\n    case 'labelFlush':\n      return properties.labelFlush(fieldDef, channel, specifiedAxis);\n    case 'labelOverlap': {\n      const scaleType = model.getScaleComponent(channel).get('type');\n      return properties.labelOverlap(fieldDef, specifiedAxis, channel, scaleType);\n    }\n    case 'orient':\n      return getSpecifiedOrDefaultValue(specifiedAxis.orient, properties.orient(channel));\n    case 'tickCount': {\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n      const size = sizeType ? model.getSizeSignalRef(sizeType)\n       : undefined;\n      return getSpecifiedOrDefaultValue(specifiedAxis.tickCount, properties.tickCount(channel, fieldDef, scaleType, size));\n    }\n    case 'title':\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = model.fieldDef(channel2);\n      // Keep undefined so we use default if title is unspecified.\n      // For other falsy value, keep them so we will hide the title.\n      const fieldDefTitle = getFieldDefTitle(model, channel);\n      const specifiedTitle = fieldDefTitle !== undefined ? fieldDefTitle :\n        specifiedAxis.title === undefined ? undefined : specifiedAxis.title;\n\n      return getSpecifiedOrDefaultValue<string | FieldDefBase<string>[]>(\n        specifiedTitle,\n        // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n        mergeTitleFieldDefs(\n          [toFieldDefBase(fieldDef)],\n          fieldDef2 ? [toFieldDefBase(fieldDef2)] : []\n        )\n      );\n    case 'values':\n      return properties.values(specifiedAxis, model, fieldDef, channel);\n  }\n  // Otherwise, return specified property.\n  return isAxisProperty(property) ? specifiedAxis[property] : undefined;\n}\n"]}