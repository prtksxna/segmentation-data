{"version":3,"file":"selection.js","sourceRoot":"","sources":["../../../../src/compile/selection/selection.ts"],"names":[],"mappings":"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","sourcesContent":["import {SignalRef} from 'vega';\nimport {selector as parseSelector} from 'vega-event-selector';\nimport {isString, stringValue} from 'vega-util';\nimport {Channel, ScaleChannel, X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {LogicalOperand} from '../../logical';\nimport {BrushConfig, SELECTION_ID, SelectionDef, SelectionResolution, SelectionType} from '../../selection';\nimport {accessPathWithDatum, Dict, logicalExpr, varName} from '../../util';\nimport {VgBinding, VgData, VgEventStream} from '../../vega.schema';\nimport {DataFlowNode} from '../data/dataflow';\nimport {TimeUnitNode} from '../data/timeunit';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport intervalCompiler from './interval';\nimport multiCompiler from './multi';\nimport {SelectionComponent} from './selection';\nimport singleCompiler from './single';\nimport {forEachTransform} from './transforms/transforms';\n\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\n\nexport interface SelectionComponent {\n  name: string;\n  type: SelectionType;\n  events: VgEventStream;\n  // predicate?: string;\n  bind?: 'scales' | VgBinding | {[key: string]: VgBinding};\n  resolve: SelectionResolution;\n  empty: 'all' | 'none';\n  mark?: BrushConfig;\n\n  _signalNames: {};\n\n  // Transforms\n  project?: ProjectComponent[];\n  fields?: any;\n  timeUnit?: TimeUnitNode;\n  scales?: Channel[];\n  toggle?: any;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n}\n\nexport interface ProjectComponent {\n  field?: string;\n  channel?: ScaleChannel;\n}\n\nexport interface SelectionCompiler {\n  signals: (model: UnitModel, selCmpt: SelectionComponent) => any[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent, signals: any[]) => any[];\n  modifyExpr: (model: UnitModel, selCmpt: SelectionComponent) => string;\n  marks?: (model: UnitModel, selCmpt: SelectionComponent, marks: any[]) => any[];\n  predicate: string; // Vega expr string to determine inclusion in selection.\n  scaleDomain: string; // Vega expr string to materialize a scale domain.\n}\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  const selCmpts: Dict<SelectionComponent> = {};\n  const selectionConfig = model.config.selection;\n\n  for (let name in selDefs) {\n    if (!selDefs.hasOwnProperty(name)) {\n      continue;\n    }\n\n    const selDef = selDefs[name];\n    const cfg = selectionConfig[selDef.type];\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = {...cfg[key], ...selDef[key]};\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] || selDef[key];\n      }\n    }\n\n    name = varName(name);\n    const selCmpt = (selCmpts[name] = {\n      ...selDef,\n      name: name,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on\n    } as SelectionComponent);\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.parse) {\n        txCompiler.parse(model, selDef, selCmpt);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: any[]) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    signals.push.apply(signals, selCompiler.signals(model, selCmpt));\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n\n    signals.push({\n      name: name + MODIFY,\n      on: [\n        {\n          events: {signal: name + TUPLE},\n          update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n        }\n      ]\n    });\n  });\n\n  const facetModel = getFacetModel(model);\n  if (signals.length && facetModel) {\n    const name = stringValue(facetModel.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [\n        {\n          events: parseSelector('mousemove', 'scope'),\n          update: `isTuple(facet) ? facet : group(${name}).datum`\n        }\n      ]\n    });\n  }\n\n  return signals;\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: any[]) {\n  let needsUnit = false;\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n\n    needsUnit = true;\n  });\n\n  if (needsUnit) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (!hasUnit.length) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{events: 'mousemove', update: 'isTuple(group()) ? group() : unit'}]\n      });\n    }\n  }\n\n  return signals;\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: VgData[]): VgData[] {\n  forEachSelection(model, selCmpt => {\n    const contains = data.filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      data.push({name: selCmpt.name + STORE});\n    }\n  });\n\n  return data;\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n\n  return marks;\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  model.children.forEach(child => {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  });\n\n  return marks;\n}\n\nexport function selectionPredicate(model: Model, selections: LogicalOperand<string>, dfnode?: DataFlowNode): string {\n  const stores: string[] = [];\n  function expr(name: string): string {\n    const vname = varName(name);\n    const selCmpt = model.getSelectionComponent(vname, name);\n    const store = stringValue(vname + STORE);\n\n    if (selCmpt.timeUnit) {\n      const child = dfnode || model.component.data.raw;\n      const tunode = selCmpt.timeUnit.clone();\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return (\n      compiler(selCmpt.type).predicate +\n      `(${store}, datum` +\n      (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`)\n    );\n  }\n\n  const predicateStr = logicalExpr(selections, expr);\n  return (\n    (stores.length ? '!(' + stores.map(s => `length(data(${s}))`).join(' || ') + ') || ' : '') + `(${predicateStr})`\n  );\n}\n\n// Selections are parsed _after_ scales. If a scale domain is set to\n// use a selection, the SELECTION_DOMAIN constant is used as the\n// domainRaw.signal during scale.parse and then replaced with the necessary\n// selection expression function during scale.assemble. To not pollute the\n// type signatures to account for this setup, the selection domain definition\n// is coerced to a string and appended to SELECTION_DOMAIN.\nexport function isRawSelectionDomain(domainRaw: SignalRef) {\n  return domainRaw.signal.indexOf(SELECTION_DOMAIN) >= 0;\n}\nexport function selectionScaleDomain(model: Model, domainRaw: SignalRef): SignalRef {\n  const selDomain = JSON.parse(domainRaw.signal.replace(SELECTION_DOMAIN, ''));\n  const name = varName(selDomain.selection);\n\n  let selCmpt = model.component.selection && model.component.selection[name];\n  if (selCmpt) {\n    warn('Use \"bind\": \"scales\" to setup a binding for scales and selections within the same view.');\n  } else {\n    selCmpt = model.getSelectionComponent(name, selDomain.selection);\n    if (!selDomain.encoding && !selDomain.field) {\n      selDomain.field = selCmpt.project[0].field;\n      if (selCmpt.project.length > 1) {\n        warn(\n          'A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n            `Using \"field\": ${stringValue(selDomain.field)}.`\n        );\n      }\n    }\n    return {\n      signal:\n        compiler(selCmpt.type).scaleDomain +\n        `(${stringValue(name + STORE)}, ${stringValue(selDomain.encoding || null)}, ` +\n        stringValue(selDomain.field || null) +\n        (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`)\n    };\n  }\n\n  return {signal: 'null'};\n}\n\n// Utility functions\n\nfunction forEachSelection(model: Model, cb: (selCmpt: SelectionComponent, selCompiler: SelectionCompiler) => void) {\n  const selections = model.component.selection;\n  for (const name in selections) {\n    if (selections.hasOwnProperty(name)) {\n      const sel = selections[name];\n      cb(sel, compiler(sel.type));\n    }\n  }\n}\n\nfunction compiler(type: SelectionType): SelectionCompiler {\n  switch (type) {\n    case 'single':\n      return singleCompiler;\n    case 'multi':\n      return multiCompiler;\n    case 'interval':\n      return intervalCompiler;\n  }\n  return null;\n}\n\nfunction getFacetModel(model: Model): FacetModel {\n  let parent = model.parent;\n  while (parent) {\n    if (isFacetModel(parent)) {\n      break;\n    }\n    parent = parent.parent;\n  }\n\n  return parent as FacetModel;\n}\n\nexport function unitName(model: Model) {\n  let name = stringValue(model.name);\n  const facet = getFacetModel(model);\n  if (facet) {\n    name +=\n      (facet.facet.row ? ` + '_' + (${accessPathWithDatum(facet.vgField('row'), 'facet')})` : '') +\n      (facet.facet.column ? ` + '_' + (${accessPathWithDatum(facet.vgField('column'), 'facet')})` : '');\n  }\n  return name;\n}\n\nexport function requiresSelectionId(model: Model) {\n  let identifier = false;\n  forEachSelection(model, selCmpt => {\n    identifier = identifier || selCmpt.project.some(proj => proj.field === SELECTION_ID);\n  });\n  return identifier;\n}\n\nexport function channelSignalName(selCmpt: SelectionComponent, channel: Channel, range: 'visual' | 'data') {\n  const sgNames = selCmpt._signalNames || (selCmpt._signalNames = {});\n  if (sgNames[channel] && sgNames[channel][range]) {\n    return sgNames[channel][range];\n  }\n\n  sgNames[channel] = sgNames[channel] || {};\n  const basename = varName(selCmpt.name + '_' + (range === 'visual' ? channel : selCmpt.fields[channel]));\n  let name = basename;\n  let counter = 1;\n  while (sgNames[name]) {\n    name = `${basename}_${counter++}`;\n  }\n\n  return (sgNames[name] = sgNames[channel][range] = name);\n}\n\nexport function positionalProjections(selCmpt: SelectionComponent) {\n  let x: ProjectComponent = null;\n  let xi: number = null;\n  let y: ProjectComponent = null;\n  let yi: number = null;\n\n  selCmpt.project.forEach((p, i) => {\n    if (p.channel === X) {\n      x = p;\n      xi = i;\n    } else if (p.channel === Y) {\n      y = p;\n      yi = i;\n    }\n  });\n  return {x, xi, y, yi};\n}\n"]}