{"version":3,"file":"properties.js","sourceRoot":"","sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {Align, AxisOrient, SignalRef} from 'vega';\nimport {Axis} from '../../axis';\nimport {binToString, isBinning} from '../../bin';\nimport {PositionScaleChannel, X, Y} from '../../channel';\nimport {FieldDef, valueArray} from '../../fielddef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain, isSelectionDomain, ScaleType} from '../../scale';\nimport {NOMINAL, ORDINAL, QUANTITATIVE} from '../../type';\nimport {contains} from '../../util';\nimport {UnitModel} from '../unit';\nimport {getAxisConfig} from './config';\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function grid(scaleType: ScaleType, fieldDef: FieldDef<string>) {\n  return !hasDiscreteDomain(scaleType) && !isBinning(fieldDef.bin);\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function labelAngle(\n  model: UnitModel,\n  specifiedAxis: Axis,\n  channel: PositionScaleChannel,\n  fieldDef: FieldDef<string>\n) {\n  // try axis value\n  if (specifiedAxis.labelAngle !== undefined) {\n    // Make angle within [0,360)\n    return ((specifiedAxis.labelAngle % 360) + 360) % 360;\n  } else {\n    // try axis config value\n    const angle = getAxisConfig(\n      'labelAngle',\n      model.config,\n      channel,\n      orient(channel),\n      model.getScaleComponent(channel).get('type')\n    );\n    if (angle !== undefined) {\n      return ((angle % 360) + 360) % 360;\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldDef.type)) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\n\nexport function labelBaseline(angle: number, axisOrient: AxisOrient) {\n  if (angle !== undefined) {\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle <= 45 || 315 <= angle) {\n        return axisOrient === 'top' ? 'bottom' : 'top';\n      } else if (135 <= angle && angle <= 225) {\n        return axisOrient === 'top' ? 'top' : 'bottom';\n      } else {\n        return 'middle';\n      }\n    } else {\n      if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n        return 'middle';\n      } else if (45 <= angle && angle <= 135) {\n        return axisOrient === 'left' ? 'top' : 'bottom';\n      } else {\n        return axisOrient === 'left' ? 'bottom' : 'top';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function labelAlign(angle: number, axisOrient: AxisOrient): Align {\n  if (angle !== undefined) {\n    angle = ((angle % 360) + 360) % 360;\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle % 180 === 0) {\n        return 'center';\n      } else if (0 < angle && angle < 180) {\n        return axisOrient === 'top' ? 'right' : 'left';\n      } else {\n        return axisOrient === 'top' ? 'left' : 'right';\n      }\n    } else {\n      if ((angle + 90) % 180 === 0) {\n        return 'center';\n      } else if (90 <= angle && angle < 270) {\n        return axisOrient === 'left' ? 'left' : 'right';\n      } else {\n        return axisOrient === 'left' ? 'right' : 'left';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function labelFlush(fieldDef: FieldDef<string>, channel: PositionScaleChannel, specifiedAxis: Axis) {\n  if (specifiedAxis.labelFlush !== undefined) {\n    return specifiedAxis.labelFlush;\n  }\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function labelOverlap(\n  fieldDef: FieldDef<string>,\n  specifiedAxis: Axis,\n  channel: PositionScaleChannel,\n  scaleType: ScaleType\n) {\n  if (specifiedAxis.labelOverlap !== undefined) {\n    return specifiedAxis.labelOverlap;\n  }\n\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n    return true;\n  }\n\n  return undefined;\n}\n\nexport function orient(channel: PositionScaleChannel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function tickCount(\n  channel: PositionScaleChannel,\n  fieldDef: FieldDef<string>,\n  scaleType: ScaleType,\n  size: SignalRef,\n  scaleName: string,\n  specifiedAxis: Axis\n) {\n  if (\n    !hasDiscreteDomain(scaleType) &&\n    scaleType !== 'log' &&\n    !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)\n  ) {\n    if (specifiedAxis.tickStep) {\n      return {signal: `(domain('${scaleName}')[1] - domain('${scaleName}')[0]) / ${specifiedAxis.tickStep} + 1`};\n    } else if (isBinning(fieldDef.bin)) {\n      // for binned data, we don't want more ticks than maxbins\n      return {signal: `ceil(${size.signal}/20)`};\n    }\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function values(\n  specifiedAxis: Axis,\n  model: UnitModel,\n  fieldDef: FieldDef<string>,\n  channel: PositionScaleChannel\n) {\n  const vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    if (isBinning(fieldDef.bin)) {\n      const domain = model.scaleDomain(channel);\n      if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n        // explicit value\n        return vals;\n      }\n      const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n      return {signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`};\n    } else if (specifiedAxis.tickStep) {\n      const scaleName = model.scaleName(channel);\n      const step = specifiedAxis.tickStep;\n      return {signal: `sequence(domain('${scaleName}')[0], domain('${scaleName}')[1] + ${step}, ${step})`};\n    }\n  }\n\n  return undefined;\n}\n"]}