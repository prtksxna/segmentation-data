{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/data/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {MAIN, ParseValue, RAW} from '../../data';\nimport * as log from '../../log';\nimport {\n  isAggregate,\n  isBin,\n  isCalculate,\n  isFilter,\n  isFlatten,\n  isFold,\n  isImpute,\n  isLookup,\n  isSample,\n  isStack,\n  isTimeUnit,\n  isWindow\n} from '../../transform';\nimport {Dict, keys} from '../../util';\nimport {isFacetModel, isLayerModel, isUnitModel, Model} from '../model';\nimport {requiresSelectionId} from '../selection/selection';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {AncestorParse, DataComponent} from './index';\nimport {LookupNode} from './lookup';\nimport {SampleTransformNode} from './sample';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nfunction parseRoot(model: Model, sources: Dict<SourceNode>): DataFlowNode {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n    const source = new SourceNode(model.data);\n    const hash = source.hash();\n    if (hash in sources) {\n      // use a reference if we already have a source\n      return sources[hash];\n    } else {\n      // otherwise add a new one\n      sources[hash] = source;\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot\n      ? model.parent.component.data.facetRoot\n      : model.parent.component.data.main;\n  }\n}\n\n/**\n * Parses a transforms array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head: DataFlowNode, model: Model, ancestorParse: AncestorParse): DataFlowNode {\n  let lookupCounter = 0;\n\n  model.transforms.forEach(t => {\n    let derivedType: ParseValue = undefined;\n    let transformNode: DataFlowNode;\n\n    if (isCalculate(t)) {\n      transformNode = head = new CalculateNode(head, t);\n      derivedType = 'derived';\n    } else if (isFilter(t)) {\n      transformNode = head = ParseNode.makeImplicitFromFilterTransform(head, t, ancestorParse) || head;\n\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      transformNode = head = BinNode.makeFromTransform(head, t, model);\n      derivedType = 'number';\n    } else if (isTimeUnit(t)) {\n      transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n      derivedType = 'date';\n    } else if (isAggregate(t)) {\n      transformNode = head = AggregateNode.makeFromTransform(head, t);\n      derivedType = 'number';\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    } else if (isLookup(t)) {\n      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n      derivedType = 'derived';\n    } else if (isWindow(t)) {\n      transformNode = head = new WindowTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isStack(t)) {\n      transformNode = head = StackNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isFold(t)) {\n      transformNode = head = new FoldTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isFlatten(t)) {\n      transformNode = head = new FlattenTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isSample(t)) {\n      head = new SampleTransformNode(head, t);\n    } else if (isImpute(t)) {\n      transformNode = head = ImputeNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      return;\n    }\n\n    if (transformNode && derivedType !== undefined) {\n      for (const field of keys(transformNode.producedFields())) {\n        ancestorParse.set(field, derivedType, false);\n      }\n    }\n  });\n\n  return head;\n}\n\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model: Model): DataComponent {\n  let head = parseRoot(model, model.component.data.sources);\n\n  const {outputNodes, outputNodeRefCounts} = model.component.data;\n  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n\n  // format.parse: null means disable parsing\n  if (model.data && model.data.format && model.data.format.parse === null) {\n    ancestorParse.parseNothing = true;\n  }\n\n  head = ParseNode.makeExplicit(head, model, ancestorParse) || head;\n\n  // Default discrete selections require an identifier transform to\n  // uniquely identify data points as the _id field is volatile. Add\n  // this transform at the head of our pipeline such that the identifier\n  // field is available for all subsequent datasets. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n  if (requiresSelectionId(model) && (isUnitModel(model) || isLayerModel(model))) {\n    head = new IdentifierNode(head);\n  }\n\n  // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  }\n\n  head = ParseNode.makeImplicitFromEncoding(head, model, ancestorParse) || head;\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n\n    head = TimeUnitNode.makeFromEncoding(head, model) || head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  }\n\n  // add an output node pre aggregation\n  const rawName = model.getName(RAW);\n  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n    head = ImputeNode.makeFromEncoding(head, model) || head;\n    head = StackNode.makeFromEncoding(head, model) || head;\n  }\n\n  // output node for marks\n  const mainName = model.getName(MAIN);\n  const main = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  // add facet marker\n  let facetRoot = null;\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet');\n\n    // Derive new sort index field for facet's sort array\n    head = CalculateNode.parseAllForSortIndex(head, model);\n\n    // Derive new aggregate (via window) for facet's sort field\n    // TODO: use JoinAggregate once we have it\n    // augment data source with new fields for crossed facet\n    head = WindowTransformNode.makeFromFacet(head, model.facet) || head;\n\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n    head = facetRoot;\n  }\n\n  return {\n    ...model.component.data,\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  };\n}\n"]}