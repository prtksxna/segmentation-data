{"version":3,"file":"aggregate.js","sourceRoot":"","sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":";;;AACA,iCAAoC;AACpC,yCAAsD;AACtD,2CAAiD;AACjD,qDAAiC;AAEjC,mCAA8F;AAE9F,oCAA2C;AAE3C,uCAAuD;AAEvD,SAAS,YAAY,CAAC,IAAgC,EAAE,OAAgB,EAAE,QAA0B;IAClG,IAAI,eAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QAC3B,IAAI,CAAC,kBAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC;QACnC,IAAI,CAAC,kBAAO,CAAC,QAAQ,EAAE,EAAC,SAAS,EAAE,KAAK,EAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAEnD,IAAI,yBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE;YACvC,IAAI,CAAC,kBAAO,CAAC,QAAQ,EAAE,EAAC,SAAS,EAAE,OAAO,EAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACtD;KACF;SAAM;QACL,IAAI,CAAC,kBAAO,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC;KAChC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,aAAa,CAAC,cAAkC,EAAE,aAAiC;IAC1F,KAAK,IAAM,CAAC,IAAI,aAAa,EAAE;QAC7B,IAAI,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE;YACnC,6FAA6F;YAC7F,IAAM,GAAG,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;YAC7B,KAAK,IAAM,EAAE,IAAI,GAAG,EAAE;gBACpB,IAAI,GAAG,CAAC,cAAc,CAAC,EAAE,CAAC,EAAE;oBAC1B,IAAI,CAAC,IAAI,cAAc,EAAE;wBACvB,yCAAyC;wBACzC,cAAc,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;qBACjC;yBAAM;wBACL,cAAc,CAAC,CAAC,CAAC,GAAG,EAAC,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,EAAC,CAAC;qBACnC;iBACF;aACF;SACF;KACF;AACH,CAAC;AAED;IAAmC,yCAAa;IAK9C;;;OAGG;IACH,uBACE,MAAoB,EACZ,UAAqB,EACrB,QAA+C;QAHzD,YAKE,kBAAM,MAAM,CAAC,SACd;QAJS,gBAAU,GAAV,UAAU,CAAW;QACrB,cAAQ,GAAR,QAAQ,CAAuC;;IAGzD,CAAC;IAdM,6BAAK,GAAZ;QACE,OAAO,IAAI,aAAa,CAAC,IAAI,uBAAM,IAAI,CAAC,UAAU,GAAG,gBAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IACjF,CAAC;IAca,8BAAgB,GAA9B,UAA+B,MAAoB,EAAE,KAAgB;QACnE,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,KAAK,CAAC,eAAe,CAAC,UAAA,EAAE;YACtB,IAAI,EAAE,CAAC,SAAS,EAAE;gBAChB,WAAW,GAAG,IAAI,CAAC;aACpB;QACH,CAAC,CAAC,CAAC;QAEH,IAAM,IAAI,GAAG,EAAE,CAAC;QAChB,IAAM,IAAI,GAAG,EAAE,CAAC;QAEhB,IAAI,CAAC,WAAW,EAAE;YAChB,8DAA8D;YAC9D,OAAO,IAAI,CAAC;SACb;QAED,KAAK,CAAC,eAAe,CAAC,UAAC,QAAQ,EAAE,OAAO;YAC/B,IAAA,8BAAS,EAAE,sBAAK,CAAa;YACpC,IAAI,SAAS,EAAE;gBACb,IAAI,SAAS,KAAK,OAAO,EAAE;oBACzB,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;oBAC5B,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,kBAAO,CAAC,QAAQ,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;iBACvD;qBAAM;oBACL,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;oBAChC,IAAI,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,GAAG,kBAAO,CAAC,QAAQ,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;oBAE1D,iHAAiH;oBACjH,IAAI,wBAAc,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,cAAc,EAAE;wBAC5E,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,GAAG,kBAAO,CAAC,EAAC,KAAK,OAAA,EAAE,SAAS,EAAE,KAAK,EAAC,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;wBACvE,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,GAAG,kBAAO,CAAC,EAAC,KAAK,OAAA,EAAE,SAAS,EAAE,KAAK,EAAC,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;qBACxE;iBACF;aACF;iBAAM;gBACL,YAAY,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;aACvC;QACH,CAAC,CAAC,CAAC;QAEH,IAAI,WAAI,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,WAAI,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/C,OAAO,IAAI,CAAC;SACb;QAED,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAC/C,CAAC;IAEa,+BAAiB,GAA/B,UAAgC,MAAoB,EAAE,CAAqB;QACzE,IAAM,IAAI,GAAG,EAAE,CAAC;QAChB,IAAM,IAAI,GAAG,EAAE,CAAC;QAEhB,KAAgB,UAAW,EAAX,KAAA,CAAC,CAAC,SAAS,EAAX,cAAW,EAAX,IAAW,EAAE;YAAxB,IAAM,CAAC,SAAA;YACH,IAAA,SAAE,EAAE,eAAK,EAAE,SAAE,CAAM;YAC1B,IAAI,EAAE,EAAE;gBACN,IAAI,EAAE,KAAK,OAAO,EAAE;oBAClB,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;oBAC5B,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,kBAAO,CAAC,CAAC,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;iBACtD;qBAAM;oBACL,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;oBAChC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,IAAI,kBAAO,CAAC,CAAC,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;iBACnD;aACF;SACF;QAED,KAAgB,UAAe,EAAf,KAAA,CAAC,CAAC,OAAO,IAAI,EAAE,EAAf,cAAe,EAAf,IAAe,EAAE;YAA5B,IAAM,CAAC,SAAA;YACV,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SAChB;QAED,IAAI,WAAI,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,WAAI,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/C,OAAO,IAAI,CAAC;SACb;QAED,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IAC/C,CAAC;IAEM,6BAAK,GAAZ,UAAa,KAAoB;QAC/B,IAAI,CAAC,aAAM,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,EAAE;YAC9C,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC7C,KAAK,CAAC,MAAM,EAAE,CAAC;SAChB;aAAM;YACL,GAAG,CAAC,KAAK,CAAC,oCAAoC,CAAC,CAAC;SACjD;IACH,CAAC;IAEM,qCAAa,GAApB,UAAqB,MAAgB;QAArC,iBAEC;QADC,MAAM,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,KAAI,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,EAA3B,CAA2B,CAAC,CAAC;IACnD,CAAC;IAEM,uCAAe,GAAtB;QACE,IAAM,GAAG,GAAG,EAAE,CAAC;QAEf,WAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,EAAf,CAAe,CAAC,CAAC;QACpD,WAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,EAAf,CAAe,CAAC,CAAC;QAElD,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,sCAAc,GAArB;QACE,IAAM,GAAG,GAAG,EAAE,CAAC;QAEf,KAAoB,UAAmB,EAAnB,KAAA,WAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAnB,cAAmB,EAAnB,IAAmB,EAAE;YAApC,IAAM,KAAK,SAAA;YACd,KAAiB,UAA0B,EAA1B,KAAA,WAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAA1B,cAA0B,EAA1B,IAA0B,EAAE;gBAAxC,IAAM,EAAE,SAAA;gBACX,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAO,EAAE,SAAI,KAAO,CAAC,GAAG,IAAI,CAAC;aAC1D;SACF;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,4BAAI,GAAX;QACE,OAAO,eAAa,WAAI,CAAC,EAAC,UAAU,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAC,CAAG,CAAC;IACrF,CAAC;IAEM,gCAAQ,GAAf;QACE,IAAM,GAAG,GAAkB,EAAE,CAAC;QAC9B,IAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,IAAM,EAAE,GAAa,EAAE,CAAC;QAExB,KAAoB,UAAmB,EAAnB,KAAA,WAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAnB,cAAmB,EAAnB,IAAmB,EAAE;YAApC,IAAM,KAAK,SAAA;YACd,KAAiB,UAA0B,EAA1B,KAAA,WAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAA1B,cAA0B,EAA1B,IAA0B,EAAE;gBAAxC,IAAM,EAAE,SAAA;gBACX,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAClC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACb,MAAM,CAAC,IAAI,CAAC,yBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC;aACxC;SACF;QAED,IAAM,MAAM,GAAyB;YACnC,IAAI,EAAE,WAAW;YACjB,OAAO,EAAE,WAAI,CAAC,IAAI,CAAC,UAAU,CAAC;YAC9B,GAAG,KAAA;YACH,MAAM,QAAA;YACN,EAAE,IAAA;SACH,CAAC;QAEF,OAAO,MAAM,CAAC;IAChB,CAAC;IACH,oBAAC;AAAD,CAAC,AAtJD,CAAmC,wBAAa,GAsJ/C;AAtJY,sCAAa","sourcesContent":["import {AggregateOp} from 'vega';\nimport {isBinning} from '../../bin';\nimport {Channel, isScaleChannel} from '../../channel';\nimport {FieldDef, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, differ, duplicate, hash, keys, replacePathInField, StringSet} from '../../util';\nimport {VgAggregateTransform} from '../../vega.schema';\nimport {binRequiresRange} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\nfunction addDimension(dims: {[field: string]: boolean}, channel: Channel, fieldDef: FieldDef<string>) {\n  if (isBinning(fieldDef.bin)) {\n    dims[vgField(fieldDef, {})] = true;\n    dims[vgField(fieldDef, {binSuffix: 'end'})] = true;\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims[vgField(fieldDef, {binSuffix: 'range'})] = true;\n    }\n  } else {\n    dims[vgField(fieldDef)] = true;\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Dict<Dict<string>>, childMeasures: Dict<Dict<string>>) {\n  for (const f in childMeasures) {\n    if (childMeasures.hasOwnProperty(f)) {\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      const ops = childMeasures[f];\n      for (const op in ops) {\n        if (ops.hasOwnProperty(op)) {\n          if (f in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[f][op] = ops[op];\n          } else {\n            parentMeasures[f] = {op: ops[op]};\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends TransformNode {\n  public clone() {\n    return new AggregateNode(null, {...this.dimensions}, duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(\n    parent: DataFlowNode,\n    private dimensions: StringSet,\n    private measures: Dict<{[key in AggregateOp]?: string}>\n  ) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas = {};\n    const dims = {};\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = vgField(fieldDef, {forAs: true});\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][aggregate] = vgField(fieldDef, {forAs: true});\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field]['min'] = vgField({field, aggregate: 'min'}, {forAs: true});\n            meas[field]['max'] = vgField({field, aggregate: 'max'}, {forAs: true});\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef);\n      }\n    });\n\n    if (keys(dims).length + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = {};\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = as || vgField(s, {forAs: true});\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][op] = as || vgField(s, {forAs: true});\n        }\n      }\n    }\n\n    for (const s of t.groupby || []) {\n      dims[s] = true;\n    }\n\n    if (keys(dims).length + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode) {\n    if (!differ(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      other.remove();\n    } else {\n      log.debug('different dimensions, cannot merge');\n    }\n  }\n\n  public addDimensions(fields: string[]) {\n    fields.forEach(f => (this.dimensions[f] = true));\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    keys(this.dimensions).forEach(f => (out[f] = true));\n    keys(this.measures).forEach(m => (out[m] = true));\n\n    return out;\n  }\n\n  public producedFields() {\n    const out = {};\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        out[this.measures[field][op] || `${op}_${field}`] = true;\n      }\n    }\n\n    return out;\n  }\n\n  public hash() {\n    return `Aggregate ${hash({dimensions: this.dimensions, measures: this.measures})}`;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        as.push(this.measures[field][op]);\n        ops.push(op);\n        fields.push(replacePathInField(field));\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: keys(this.dimensions),\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n"]}