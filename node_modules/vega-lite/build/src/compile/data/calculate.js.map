{"version":3,"file":"calculate.js","sourceRoot":"","sources":["../../../../src/compile/data/calculate.ts"],"names":[],"mappings":";;;AAEA,2CAAkE;AAElE,6CAAsD;AACtD,mCAAuC;AAEvC,mCAAsD;AAItD,uCAAuD;AACvD,6CAAiD;AAEjD;;GAEG;AAEH;IAAmC,yCAAa;IAO9C,uBAAY,MAAoB,EAAU,SAA6B;QAAvE,YACE,kBAAM,MAAM,CAAC,SAGd;QAJyC,eAAS,GAAT,SAAS,CAAoB;QAGrE,KAAI,CAAC,gBAAgB,GAAG,gCAAkB,CAAC,KAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;;IACvE,CAAC;IARM,6BAAK,GAAZ;QACE,OAAO,IAAI,aAAa,CAAC,IAAI,EAAE,gBAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IAC5D,CAAC;IAQa,kCAAoB,GAAlC,UAAmC,MAAoB,EAAE,KAAqB;QAC5E,mDAAmD;QACnD,KAAK,CAAC,eAAe,CAAC,UAAC,QAA0B,EAAE,OAAyB;YAC1E,IAAI,CAAC,0BAAe,CAAC,QAAQ,CAAC,EAAE;gBAC9B,OAAO;aACR;YACD,IAAI,kBAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACvB,IAAA,wBAAK,EAAE,8BAAQ,CAAa;gBACnC,IAAM,IAAI,GAA6C,QAAQ,CAAC,IAAI,CAAC;gBACrE,iGAAiG;gBACjG,IAAM,SAAS,GACb,IAAI;qBACD,GAAG,CAAC,UAAC,SAAS,EAAE,CAAC;oBAChB,OAAU,iCAAqB,CAAC,EAAC,KAAK,SAAA,EAAE,QAAQ,YAAA,EAAE,KAAK,EAAE,SAAS,EAAC,CAAC,WAAM,CAAC,QAAK,CAAC;gBACnF,CAAC,CAAC;qBACD,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;gBAE5B,MAAM,GAAG,IAAI,aAAa,CAAC,MAAM,EAAE;oBACjC,SAAS,WAAA;oBACT,EAAE,EAAE,mBAAmB,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC;iBAC1D,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,sCAAc,GAArB;QACE,IAAM,GAAG,GAAG,EAAE,CAAC;QACf,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;QAC9B,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,uCAAe,GAAtB;QACE,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAEM,gCAAQ,GAAf;QACE,OAAO;YACL,IAAI,EAAE,SAAS;YACf,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS;YAC9B,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE;SACtB,CAAC;IACJ,CAAC;IAEM,4BAAI,GAAX;QACE,OAAO,eAAa,WAAI,CAAC,IAAI,CAAC,SAAS,CAAG,CAAC;IAC7C,CAAC;IACH,oBAAC;AAAD,CAAC,AA5DD,CAAmC,wBAAa,GA4D/C;AA5DY,sCAAa;AA8D1B,SAAgB,mBAAmB,CAAC,QAA0B,EAAE,OAAyB,EAAE,GAAoB;IAC7G,OAAO,kBAAO,CAAC,QAAQ,qBAAG,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,YAAY,IAAK,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,CAAC;AACpF,CAAC;AAFD,kDAEC","sourcesContent":["import {SingleDefChannel} from '../../channel';\nimport {DateTime} from '../../datetime';\nimport {FieldDef, isScaleFieldDef, vgField} from '../../fielddef';\nimport {FieldRefOption} from '../../fielddef';\nimport {fieldFilterExpression} from '../../predicate';\nimport {isSortArray} from '../../sort';\nimport {CalculateTransform} from '../../transform';\nimport {duplicate, hash, StringSet} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {ModelWithField} from '../model';\n\nimport {DataFlowNode, TransformNode} from './dataflow';\nimport {getDependentFields} from './expressions';\n\n/**\n * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.\n */\n\nexport class CalculateNode extends TransformNode {\n  private _dependentFields: StringSet;\n\n  public clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: CalculateTransform) {\n    super(parent);\n\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  public static parseAllForSortIndex(parent: DataFlowNode, model: ModelWithField) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef: FieldDef<string>, channel: SingleDefChannel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {field, timeUnit} = fieldDef;\n        const sort: (number | string | boolean | DateTime)[] = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate =\n          sort\n            .map((sortValue, i) => {\n              return `${fieldFilterExpression({field, timeUnit, equal: sortValue})} ? ${i} : `;\n            })\n            .join('') + sort.length;\n\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {forAs: true})\n        });\n      }\n    });\n    return parent;\n  }\n\n  public producedFields() {\n    const out = {};\n    out[this.transform.as] = true;\n    return out;\n  }\n\n  public dependentFields() {\n    return this._dependentFields;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  public hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n}\n\nexport function sortArrayIndexField(fieldDef: FieldDef<string>, channel: SingleDefChannel, opt?: FieldRefOption) {\n  return vgField(fieldDef, {prefix: channel, suffix: 'sort_index', ...(opt || {})});\n}\n"]}