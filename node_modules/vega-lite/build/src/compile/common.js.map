{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/compile/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {Channel, isScaleChannel} from '../channel';\nimport {Config, StyleConfigIndex, ViewConfig} from '../config';\nimport {\n  FieldDef,\n  FieldDefBase,\n  FieldRefOption,\n  isScaleFieldDef,\n  isTimeFieldDef,\n  OrderFieldDef,\n  ValueDef,\n  vgField\n} from '../fielddef';\nimport {GuideEncodingEntry} from '../guide';\nimport {MarkConfig, MarkDef, TextConfig} from '../mark';\nimport {ScaleType} from '../scale';\nimport {formatExpression, TimeUnit} from '../timeunit';\nimport {QUANTITATIVE} from '../type';\nimport {contains, getFirstDefined, keys, stringify} from '../util';\nimport {VgEncodeChannel, VgEncodeEntry, VgMarkConfig, VgSort} from '../vega.schema';\nimport {AxisComponentProps} from './axis/component';\nimport {wrapCondition} from './mark/mixins';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\nexport function applyConfig(\n  e: VgEncodeEntry,\n  config: ViewConfig | MarkConfig | TextConfig, // TODO(#1842): consolidate MarkConfig | TextConfig?\n  propsList: string[]\n) {\n  for (const property of propsList) {\n    const value = config[property];\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style || []);\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(\n  prop: P,\n  mark: MarkDef,\n  config: Config,\n  {skipGeneralMarkConfig = false}: {skipGeneralMarkConfig?: boolean} = {}\n): MarkConfig[P] {\n  return getFirstDefined(\n    // style config has highest precedence\n    getStyleConfig(prop, mark, config.style),\n    // then mark-specific config\n    config[mark.type][prop],\n    // then general mark config (if not skipped)\n    skipGeneralMarkConfig ? undefined : config.mark[prop]\n  );\n}\n\nexport function getStyleConfig<P extends keyof MarkConfig>(prop: P, mark: MarkDef, styleConfigIndex: StyleConfigIndex) {\n  const styles = getStyles(mark);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n    const p = prop as keyof VgMarkConfig;\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n  return value;\n}\n\nexport function formatSignalRef(\n  fieldDef: FieldDef<string>,\n  specifiedFormat: string,\n  expr: 'datum' | 'parent',\n  config: Config\n) {\n  const format = numberFormat(fieldDef, specifiedFormat, config);\n  if (isBinning(fieldDef.bin)) {\n    const startField = vgField(fieldDef, {expr});\n    const endField = vgField(fieldDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(startField, endField, format, config)\n    };\n  } else if (fieldDef.type === 'quantitative') {\n    return {\n      signal: `${formatExpr(vgField(fieldDef, {expr, binSuffix: 'range'}), format)}`\n    };\n  } else if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(\n        vgField(fieldDef, {expr}),\n        fieldDef.timeUnit,\n        specifiedFormat,\n        config.text.shortTimeLabels,\n        config.timeFormat,\n        isUTCScale,\n        true\n      )\n    };\n  } else {\n    return {\n      signal: `''+${vgField(fieldDef, {expr})}`\n    };\n  }\n}\n\n/**\n * Returns number format for a fieldDef\n *\n * @param format explicitly specified format\n */\nexport function numberFormat(fieldDef: FieldDef<string>, specifiedFormat: string, config: Config) {\n  if (fieldDef.type === QUANTITATIVE) {\n    // add number format for quantitative type only\n\n    // Specified format in axis/legend has higher precedence than fieldDef.format\n    if (specifiedFormat) {\n      return specifiedFormat;\n    }\n\n    // TODO: need to make this work correctly for numeric ordinal / nominal type\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nexport function numberFormatExpr(field: string, specifiedFormat: string, config: Config) {\n  return formatExpr(field, specifiedFormat || config.numberFormat);\n}\n\nexport function binFormatExpression(startField: string, endField: string, format: string, config: Config) {\n  return `${startField} === null || isNaN(${startField}) ? \"null\" : ${numberFormatExpr(\n    startField,\n    format,\n    config\n  )} + \" - \" + ${numberFormatExpr(endField, format, config)}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(\n  field: string,\n  timeUnit: TimeUnit,\n  format: string,\n  shortTimeLabels: boolean,\n  rawTimeFormat: string, // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale: boolean,\n  alwaysReturn: boolean = false\n): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format || rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    if (format || alwaysReturn) {\n      return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels, isUTCScale);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(\n  orderDef: OrderFieldDef<string> | OrderFieldDef<string>[],\n  fieldRefOption?: FieldRefOption\n): VgSort {\n  return (isArray(orderDef) ? orderDef : [orderDef]).reduce(\n    (s, orderChannelDef) => {\n      s.field.push(vgField(orderChannelDef, fieldRefOption));\n      s.order.push(orderChannelDef.sort || 'ascending');\n      return s;\n    },\n    {field: [], order: []}\n  );\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: FieldDefBase<string>[], f2: FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (stringify(fieldDef1) === stringify(fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: string, title2: string) {\n  return title1 === title2\n    ? title1 // if title is the same just use one of them\n    : title1 + ', ' + title2; // join title with comma if different\n}\n\nexport function mergeTitleComponent(v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>) {\n  if (isArray(v1.value) && isArray(v2.value)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1.value, v2.value)\n    };\n  } else if (!isArray(v1.value) && !isArray(v2.value)) {\n    return {\n      explicit: v1.explicit, // keep the old explicit\n      value: mergeTitle(v1.value, v2.value)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef: FieldDef<string>, channel: Channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only use this method with binned field defs');\n    return false;\n  }\n\n  // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n  return isScaleChannel(channel) && contains(['ordinal', 'nominal'], fieldDef.type);\n}\n\nexport function guideEncodeEntry(encoding: GuideEncodingEntry, model: UnitModel) {\n  return keys(encoding).reduce((encode, channel: VgEncodeChannel) => {\n    const valueDef = encoding[channel];\n    return {\n      ...encode,\n      ...wrapCondition(model, valueDef, channel, (x: ValueDef) => ({value: x.value}))\n    };\n  }, {});\n}\n"]}