{"version":3,"file":"valueref.js","sourceRoot":"","sources":["../../../../src/compile/mark/valueref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport {SignalRef} from 'vega';\nimport {isArray, isFunction, isString} from 'vega-util';\nimport {isBinned, isBinning} from '../../bin';\nimport {Channel, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {\n  ChannelDef,\n  ChannelDefWithCondition,\n  FieldDef,\n  FieldRefOption,\n  format,\n  isFieldDef,\n  isValueDef,\n  TextFieldDef,\n  title,\n  vgField\n} from '../../fielddef';\nimport * as log from '../../log';\nimport {Mark, MarkDef} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {QUANTITATIVE} from '../../type';\nimport {contains, some} from '../../util';\nimport {VgValueRef} from '../../vega.schema';\nimport {binRequiresRange, formatSignalRef} from '../common';\nimport {ScaleComponent} from '../scale/component';\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function position(\n  channel: 'x' | 'y',\n  channelDef: ChannelDef<string>,\n  channel2Def: ChannelDef<string>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'});\n  }\n  return midPoint(channel, channelDef, channel2Def, scaleName, scale, stack, defaultRef);\n}\n\n/**\n * @return Vega ValueRef for normal x2- or y2-position without projection\n */\nexport function position2(\n  channel: 'x2' | 'y2',\n  aFieldDef: ChannelDef<string>,\n  a2fieldDef: ChannelDef<string>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  if (\n    isFieldDef(aFieldDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return fieldRef(aFieldDef, scaleName, {suffix: 'start'});\n  }\n  return midPoint(channel, a2fieldDef, undefined, scaleName, scale, stack, defaultRef);\n}\n\nexport function getOffset(channel: 'x' | 'y' | 'x2' | 'y2', markDef: MarkDef) {\n  const offsetChannel = channel + 'Offset';\n  // TODO: in the future read from encoding channel too\n\n  const markDefOffsetValue = markDef[offsetChannel];\n  if (markDefOffsetValue) {\n    return markDefOffsetValue;\n  }\n\n  return undefined;\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin(fieldDef: FieldDef<string>, scaleName: string, side: 'start' | 'end', offset?: number) {\n  const binSuffix = side === 'start' ? undefined : 'end';\n  return fieldRef(fieldDef, scaleName, {binSuffix}, offset ? {offset} : {});\n}\n\nexport function fieldRef(\n  fieldDef: FieldDef<string>,\n  scaleName: string,\n  opt: FieldRefOption,\n  mixins?: {offset?: number | VgValueRef; band?: number | boolean}\n): VgValueRef {\n  const ref: VgValueRef = {\n    ...(scaleName ? {scale: scaleName} : {}),\n    field: vgField(fieldDef, opt)\n  };\n\n  if (mixins) {\n    return {\n      ...ref,\n      ...mixins\n    };\n  }\n  return ref;\n}\n\nexport function bandRef(scaleName: string, band: number | boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nfunction binMidSignal(scaleName: string, fieldDef: FieldDef<string>, fieldDef2?: FieldDef<string>) {\n  const start = vgField(fieldDef, {expr: 'datum'});\n  const end =\n    fieldDef2 !== undefined\n      ? vgField(fieldDef2, {expr: 'datum'})\n      : vgField(fieldDef, {binSuffix: 'end', expr: 'datum'});\n\n  return {\n    signal: `scale(\"${scaleName}\", (${start} + ${end}) / 2)`\n  };\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(\n  channel: Channel,\n  channelDef: ChannelDef<string>,\n  channel2Def: ChannelDef<string>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  // TODO: datum support\n\n  if (channelDef) {\n    /* istanbul ignore else */\n\n    if (isFieldDef(channelDef)) {\n      if (isBinning(channelDef.bin)) {\n        // Use middle only for x an y to place marks in the center between start and end of the bin range.\n        // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n        if (contains([X, Y], channel) && channelDef.type === QUANTITATIVE) {\n          if (stack && stack.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return fieldRef(channelDef, scaleName, {binSuffix: 'mid'});\n          }\n          // For non-stack, we can just calculate bin mid on the fly using signal.\n          return binMidSignal(scaleName, channelDef);\n        }\n        return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {binSuffix: 'range'} : {});\n      } else if (isBinned(channelDef.bin)) {\n        if (isFieldDef(channel2Def)) {\n          return binMidSignal(scaleName, channelDef, channel2Def);\n        } else {\n          log.warn(log.message.channelRequiredForBinned(channel));\n        }\n      }\n\n      if (scale) {\n        const scaleType = scale.get('type');\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, {band: 0.5});\n          }\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'});\n        }\n      }\n      return fieldRef(channelDef, scaleName, {}); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n\n      if (contains(['x', 'x2'], channel) && value === 'width') {\n        return {field: {group: 'width'}};\n      } else if (contains(['y', 'y2'], channel) && value === 'height') {\n        return {field: {group: 'height'}};\n      }\n\n      return {value};\n    }\n\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  return isFunction(defaultRef) ? defaultRef() : defaultRef;\n}\n\nexport function tooltipForChannelDefs(channelDefs: FieldDef<string>[], config: Config) {\n  const keyValues: string[] = [];\n  const usedKey = {};\n  for (const fieldDef of channelDefs) {\n    const key = title(fieldDef, config, {allowDisabling: false});\n    const value = text(fieldDef, config).signal;\n    if (!usedKey[key]) {\n      keyValues.push(`\"${key}\": ${value}`);\n    }\n    usedKey[key] = true;\n  }\n  return keyValues.length ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n\nexport function text(channelDef: ChannelDefWithCondition<TextFieldDef<string>>, config: Config): VgValueRef {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return {value: channelDef.value};\n    }\n    if (isFieldDef(channelDef)) {\n      return formatSignalRef(channelDef, format(channelDef), 'datum', config);\n    }\n  }\n  return undefined;\n}\n\nexport function mid(sizeRef: SignalRef): VgValueRef {\n  return {...sizeRef, mult: 0.5};\n}\n\n/**\n * Whether the scale definitely includes zero in the domain\n */\nfunction domainDefinitelyIncludeZero(scale: ScaleComponent) {\n  if (scale.get('zero') !== false) {\n    return true;\n  }\n  const domains = scale.domains;\n  if (isArray(domains)) {\n    return some(domains, d => isArray(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);\n  }\n  return false;\n}\n\nexport function getDefaultRef(\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax',\n  channel: 'x' | 'y',\n  scaleName: string,\n  scale: ScaleComponent,\n  mark: Mark\n) {\n  return () => {\n    if (isString(defaultRef)) {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, channel, {scaleType}));\n          }\n        } else {\n          if (domainDefinitelyIncludeZero(scale)) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(\n              log.message.nonZeroScaleUsedWithLengthMark(mark, channel, {zeroFalse: scale.explicit.zero === false})\n            );\n          }\n        }\n      }\n\n      if (defaultRef === 'zeroOrMin') {\n        return channel === 'x' ? {value: 0} : {field: {group: 'height'}};\n      } else {\n        // zeroOrMax\n        return channel === 'x' ? {field: {group: 'width'}} : {value: 0};\n      }\n    }\n    return defaultRef;\n  };\n}\n"]}