{"version":3,"file":"tick.js","sourceRoot":"","sources":["../../../../src/compile/mark/tick.ts"],"names":[],"mappings":";;;AAAA,mCAA2C;AAC3C,iDAAgD;AAGhD,uDAAmC;AACnC,sDAAkC;AAErB,QAAA,IAAI,GAAiB;IAChC,MAAM,EAAE,MAAM;IAEd,WAAW,EAAE,UAAC,KAAgB;;QACrB,IAAA,qBAAM,EAAE,uBAAO,EAAE,mBAAK,EAAE,qBAAM,CAAU;QAC/C,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;QAE9B,IAAM,aAAa,GAAG,MAAM,KAAK,YAAY,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC;QACnE,IAAM,kBAAkB,GAAG,MAAM,KAAK,YAAY,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC;QAExE,4BACK,MAAM,CAAC,eAAe,CAAC,KAAK,EAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,EAAC,CAAC,EAEjE,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,EACtD,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,EAGvD,MAAM,CAAC,WAAW,CAAC,MAAM,EAAE,KAAK,EAAE;YACnC,YAAY,EAAE,WAAW,CAAC,KAAK,CAAC;YAChC,SAAS,EAAE,aAAa;SACzB,CAAC,eACD,kBAAkB,IAAG,EAAC,KAAK,EAAE,sBAAe,CAAC,OAAO,CAAC,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAC,OACxF;IACJ,CAAC;CACF,CAAC;AAEF,SAAS,WAAW,CAAC,KAAgB;IAC5B,IAAA,qBAAM,EAAE,uBAAO,CAAU;IAChC,IAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC9B,IAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,CAAC,MAAM,KAAK,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAE3E,IAAI,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE;QAC9B,OAAO,OAAO,CAAC,IAAI,CAAC;KACrB;SAAM,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;QAC7C,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;KAC7B;SAAM;QACL,IAAM,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAC1D,IAAM,SAAS,GAAG,UAAU,IAAI,2BAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC;QACrG,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YACjC,6BAA6B;YAC7B,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;SACnE;QACD,OAAO,SAAS,GAAG,GAAG,CAAC;KACxB;AACH,CAAC","sourcesContent":["import {getFirstDefined} from '../../util';\nimport {isVgRangeStep} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nexport const tick: MarkCompiler = {\n  vgMark: 'rect',\n\n  encodeEntry: (model: UnitModel) => {\n    const {config, markDef, width, height} = model;\n    const orient = markDef.orient;\n\n    const vgSizeChannel = orient === 'horizontal' ? 'width' : 'height';\n    const vgThicknessChannel = orient === 'horizontal' ? 'height' : 'width';\n\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n\n      ...mixins.pointPosition('x', model, ref.mid(width), 'xc'),\n      ...mixins.pointPosition('y', model, ref.mid(height), 'yc'),\n\n      // size / thickness => width / height\n      ...mixins.nonPosition('size', model, {\n        defaultValue: defaultSize(model),\n        vgChannel: vgSizeChannel\n      }),\n      [vgThicknessChannel]: {value: getFirstDefined(markDef.thickness, config.tick.thickness)}\n    };\n  }\n};\n\nfunction defaultSize(model: UnitModel): number {\n  const {config, markDef} = model;\n  const orient = markDef.orient;\n  const scale = model.getScaleComponent(orient === 'horizontal' ? 'x' : 'y');\n\n  if (markDef.size !== undefined) {\n    return markDef.size;\n  } else if (config.tick.bandSize !== undefined) {\n    return config.tick.bandSize;\n  } else {\n    const scaleRange = scale ? scale.get('range') : undefined;\n    const rangeStep = scaleRange && isVgRangeStep(scaleRange) ? scaleRange.step : config.scale.rangeStep;\n    if (typeof rangeStep !== 'number') {\n      // FIXME consolidate this log\n      throw new Error('Function does not handle non-numeric rangeStep');\n    }\n    return rangeStep / 1.5;\n  }\n}\n"]}