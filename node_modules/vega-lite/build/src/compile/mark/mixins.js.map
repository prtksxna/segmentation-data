{"version":3,"file":"mixins.js","sourceRoot":"","sources":["../../../../src/compile/mark/mixins.ts"],"names":[],"mappings":"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","sourcesContent":["import {array, isArray, isObject, isString} from 'vega-util';\nimport {isBinned, isBinning} from '../../bin';\nimport {Channel, NonPositionScaleChannel, SCALE_CHANNELS, ScaleChannel, X, X2, Y2} from '../../channel';\nimport {fieldDefs} from '../../encoding';\nimport {\n  ChannelDef,\n  FieldDef,\n  getFieldDef,\n  isConditionalSelection,\n  isFieldDef,\n  isValueDef,\n  ValueDef\n} from '../../fielddef';\nimport * as log from '../../log';\nimport {isPathMark, MarkDef} from '../../mark';\nimport {expression} from '../../predicate';\nimport {hasContinuousDomain} from '../../scale';\nimport {contains, Dict, getFirstDefined, keys} from '../../util';\nimport {VG_MARK_CONFIGS, VgEncodeEntry, VgValueRef} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {selectionPredicate} from '../selection/selection';\nimport {UnitModel} from '../unit';\nimport * as ref from './valueref';\n\nexport function color(model: UnitModel): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {filled, type: markType} = markDef;\n\n  const configValue = {\n    fill: getMarkConfig('fill', markDef, config),\n    stroke: getMarkConfig('stroke', markDef, config),\n    color: getMarkConfig('color', markDef, config)\n  };\n\n  const transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType)\n    ? 'transparent'\n    : undefined;\n\n  const defaultValue = {\n    fill: getFirstDefined(\n      markDef.fill,\n      configValue.fill,\n      // If there is no fill, always fill symbols, bar, geoshape\n      // with transparent fills https://github.com/vega/vega-lite/issues/1316\n      transparentIfNeeded\n    ),\n    stroke: getFirstDefined(markDef.stroke, configValue.stroke)\n  };\n\n  const colorVgChannel = filled ? 'fill' : 'stroke';\n\n  const fillStrokeMarkDefAndConfig: VgEncodeEntry = {\n    ...(defaultValue.fill\n      ? {\n          fill: {value: defaultValue.fill}\n        }\n      : {}),\n    ...(defaultValue.stroke\n      ? {\n          stroke: {value: defaultValue.stroke}\n        }\n      : {})\n  };\n\n  if (encoding.fill || encoding.stroke) {\n    // ignore encoding.color, markDef.color, config.color\n    if (markDef.color) {\n      // warn for markDef.color  (no need to warn encoding.color as it will be dropped in normalized already)\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n    }\n\n    return {\n      ...nonPosition('fill', model, {defaultValue: getFirstDefined(defaultValue.fill, transparentIfNeeded)}),\n      ...nonPosition('stroke', model, {defaultValue: defaultValue.stroke})\n    };\n  } else if (encoding.color) {\n    return {\n      ...fillStrokeMarkDefAndConfig,\n      // override them with encoded color field\n      ...nonPosition('color', model, {\n        vgChannel: colorVgChannel,\n        // apply default fill/stroke first, then color config, then transparent if needed.\n        defaultValue: getFirstDefined(\n          markDef[colorVgChannel],\n          markDef.color,\n          configValue[colorVgChannel],\n          configValue.color,\n          filled ? transparentIfNeeded : undefined\n        )\n      })\n    };\n  } else if (markDef.fill !== undefined || markDef.stroke !== undefined) {\n    // Ignore markDef.color, config.color\n    if (markDef.color) {\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in markDef, stroke: 'stroke' in markDef}));\n    }\n    return fillStrokeMarkDefAndConfig;\n  } else if (markDef.color) {\n    return {\n      ...fillStrokeMarkDefAndConfig, // in this case, fillStrokeMarkDefAndConfig only include config\n\n      // override config with markDef.color\n      [colorVgChannel]: {value: markDef.color}\n    };\n  } else if (configValue.fill !== undefined || configValue.stroke !== undefined) {\n    // ignore config.color\n    return fillStrokeMarkDefAndConfig;\n  } else if (configValue.color) {\n    return {\n      ...(transparentIfNeeded ? {fill: {value: 'transparent'}} : {}),\n      [colorVgChannel]: {value: configValue.color}\n    };\n  }\n  return {};\n}\n\nexport type Ignore = Record<'size' | 'orient', 'ignore' | 'include'>;\n\nexport function baseEncodeEntry(model: UnitModel, ignore: Ignore) {\n  const {fill, stroke} = color(model);\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...wrapInvalid(model, 'fill', fill),\n    ...wrapInvalid(model, 'stroke', stroke),\n    ...nonPosition('opacity', model),\n    ...tooltip(model),\n    ...text(model, 'href')\n  };\n}\n\nfunction wrapInvalid(model: UnitModel, channel: Channel, valueRef: VgValueRef | VgValueRef[]): VgEncodeEntry {\n  const {config, mark} = model;\n\n  if (config.invalidValues && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = validPredicate(model, {invalid: true, channels: SCALE_CHANNELS});\n    if (test) {\n      return {\n        [channel]: [\n          // prepend the invalid case\n          // TODO: support custom value\n          {test, value: null},\n          ...array(valueRef)\n        ]\n      };\n    }\n  }\n  return valueRef ? {[channel]: valueRef} : {};\n}\n\nfunction markDefProperties(mark: MarkDef, ignore: Ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop: string, value: string | number | boolean): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: {value: value}};\n  }\n  return undefined;\n}\n\nfunction validPredicate(model: UnitModel, {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields\n      .map(field => {\n        const eq = invalid ? '===' : '!==';\n        return `${field} ${eq} null ${op} ${invalid ? '' : '!'}isNaN(${field})`;\n      })\n      .join(` ${op} `);\n  }\n  return undefined;\n}\nexport function defined(model: UnitModel): VgEncodeEntry {\n  if (model.config.invalidValues === 'filter') {\n    const signal = validPredicate(model, {channels: ['x', 'y']});\n\n    if (signal) {\n      return {defined: {signal}};\n    }\n  }\n  return {};\n}\n\n/**\n * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)\n */\nexport function nonPosition(\n  channel: NonPositionScaleChannel,\n  model: UnitModel,\n  opt: {defaultValue?: number | string | boolean; vgChannel?: string; defaultRef?: VgValueRef} = {}\n): VgEncodeEntry {\n  const {defaultValue, vgChannel} = opt;\n  const defaultRef = opt.defaultRef || (defaultValue !== undefined ? {value: defaultValue} : undefined);\n\n  const channelDef = model.encoding[channel];\n\n  return wrapCondition(model, channelDef, vgChannel || channel, cDef => {\n    return ref.midPoint(\n      channel,\n      cDef,\n      undefined,\n      model.scaleName(channel),\n      model.getScaleComponent(channel),\n      null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    );\n  });\n}\n\n/**\n * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(\n  model: UnitModel,\n  channelDef: ChannelDef<string>,\n  vgChannel: string,\n  refFn: (cDef: ChannelDef<string>) => VgValueRef\n): VgEncodeEntry {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n  if (condition) {\n    const conditions = isArray(condition) ? condition : [condition];\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c) ? selectionPredicate(model, c.selection) : expression(model, c.test);\n      return {\n        test,\n        ...conditionValueRef\n      };\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n\nexport function tooltip(model: UnitModel) {\n  const {encoding, markDef, config} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: ref.tooltipForChannelDefs(channelDef, config)};\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = ref.text(cDef, model.config);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      // If tooltipDef does not exist, then use value from markDef or config\n      const markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return ref.tooltipForChannelDefs(fieldDefs(encoding), config);\n        } else {\n          return {signal: 'datum'};\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\n\nexport function text(model: UnitModel, channel: 'text' | 'href' = 'text') {\n  const channelDef = model.encoding[channel];\n  return wrapCondition(model, channelDef, channel, cDef => ref.text(cDef, model.config));\n}\n\nexport function bandPosition(fieldDef: FieldDef<string>, channel: 'x' | 'y', model: UnitModel) {\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  if (model.encoding.size || model.markDef.size !== undefined) {\n    const orient = model.markDef.orient;\n    if (orient) {\n      const centeredBandPositionMixins = {\n        // Use xc/yc and place the mark at the middle of the band\n        // This way we never have to deal with size's condition for x/y position.\n        [channel + 'c']: ref.fieldRef(fieldDef, scaleName, {}, {band: 0.5})\n      };\n\n      if (getFieldDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (isValueDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (model.markDef.size !== undefined) {\n        return {\n          ...centeredBandPositionMixins,\n          [sizeChannel]: {value: model.markDef.size}\n        };\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(model.markDef.type));\n    }\n  }\n  return {\n    [channel]: ref.fieldRef(fieldDef, scaleName, {binSuffix: 'range'}),\n    [sizeChannel]: ref.bandRef(scaleName)\n  };\n}\n\nexport function centeredBandPosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  defaultPosRef: VgValueRef,\n  defaultSizeRef: VgValueRef\n) {\n  const centerChannel: 'xc' | 'yc' = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    ...pointPosition(channel, model, defaultPosRef, centerChannel),\n    ...nonPosition('size', model, {defaultRef: defaultSizeRef, vgChannel: sizeChannel})\n  };\n}\n\nexport function binPosition(\n  fieldDef: FieldDef<string>,\n  fieldDef2: ValueDef | FieldDef<string>,\n  channel: 'x' | 'y',\n  scaleName: string,\n  spacing: number,\n  reverse: boolean\n) {\n  const binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  };\n  const channel2 = channel === X ? X2 : Y2;\n  if (isBinning(fieldDef.bin)) {\n    return {\n      [channel2]: ref.bin(fieldDef, scaleName, 'start', binSpacing[`${channel}2`]),\n      [channel]: ref.bin(fieldDef, scaleName, 'end', binSpacing[channel])\n    };\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    return {\n      [channel2]: ref.fieldRef(fieldDef, scaleName, {}, {offset: binSpacing[`${channel}2`]}),\n      [channel]: ref.fieldRef(fieldDef2, scaleName, {}, {offset: binSpacing[channel]})\n    };\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n\n/**\n * Return mixins for point (non-band) position channels.\n */\nexport function pointPosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax',\n  vgChannel?: 'x' | 'y' | 'xc' | 'yc'\n) {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, mark, stack} = model;\n\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[channel === X ? X2 : Y2];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n  const valueRef =\n    !channelDef && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n        {field: model.getName(channel)}\n      : {\n          ...ref.position(\n            channel,\n            channelDef,\n            channel2Def,\n            scaleName,\n            scale,\n            stack,\n            ref.getDefaultRef(defaultRef, channel, scaleName, scale, mark)\n          ),\n          ...(offset ? {offset} : {})\n        };\n\n  return {\n    [vgChannel || channel]: valueRef\n  };\n}\n\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nexport function pointPosition2(model: UnitModel, defaultRef: 'zeroOrMin' | 'zeroOrMax', channel: 'x2' | 'y2') {\n  const {encoding, mark, stack} = model;\n\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n  const valueRef =\n    !channelDef && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n        {field: model.getName(channel)}\n      : {\n          ...ref.position2(\n            channel,\n            channelDef,\n            encoding[channel],\n            scaleName,\n            scale,\n            stack,\n            ref.getDefaultRef(defaultRef, baseChannel, scaleName, scale, mark)\n          ),\n          ...(offset ? {offset} : {})\n        };\n\n  return {[channel]: valueRef};\n}\n"]}