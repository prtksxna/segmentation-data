{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {SCALE_CHANNELS, ScaleChannel, SHAPE, X, Y} from '../../channel';\nimport {FieldDef, getFieldDef, hasConditionalFieldDef, isFieldDef} from '../../fielddef';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  Scale,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty} from './properties';\nimport {parseScaleRange} from './range';\nimport {scaleType} from './type';\n\nexport function parseScale(model: Model) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  // range depends on zero\n  parseScaleRange(model);\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, config, mark} = model;\n\n  return SCALE_CHANNELS.reduce((scaleComponents: ScaleComponentIndex, channel: ScaleChannel) => {\n    let fieldDef: FieldDef<string>;\n    let specifiedScale: Scale | null;\n\n    const channelDef = encoding[channel];\n\n    // Don't generate scale for shape of geoshape\n    if (isFieldDef(channelDef) && mark === GEOSHAPE && channel === SHAPE && channelDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    } else if (channel === X) {\n      fieldDef = getFieldDef(encoding.x2);\n    } else if (channel === Y) {\n      fieldDef = getFieldDef(encoding.y2);\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale || {};\n\n      const sType = scaleType(specifiedScale, channel, fieldDef, mark, config.scale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + '', true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2)\n);\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = (model.component.scales = {});\n\n  const scaleTypeWithExplicitIndex: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in ScaleChannel]?: Explicit<ScaleType>\n  } = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    keys(child.component.scales).forEach((channel: ScaleChannel) => {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] = resolve.scale[channel] || defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType,\n              childScaleType,\n              'type',\n              'scale',\n              scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  }\n\n  // Merge each channel listed in the index\n  keys(scaleTypeWithExplicitIndex).forEach((channel: ScaleChannel) => {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  });\n\n  return scaleComponents;\n}\n"]}