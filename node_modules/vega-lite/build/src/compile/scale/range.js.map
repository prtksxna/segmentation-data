{"version":3,"file":"range.js","sourceRoot":"","sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray, isNumber} from 'vega-util';\nimport {Channel, COLOR, FILL, OPACITY, SCALE_CHANNELS, ScaleChannel, SHAPE, SIZE, STROKE, X, Y} from '../../channel';\nimport {Config, isVgScheme} from '../../config';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  isExtendedScheme,\n  Range,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty,\n  Scheme\n} from '../../scale';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {isVgRangeStep, VgRange, VgScheme} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\nimport {parseNonUnitScaleProperty} from './properties';\n\nexport type RangeMixins = {range: Range} | {rangeStep: number} | {scheme: Scheme};\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'rangeStep', 'scheme'];\n\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nfunction parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  SCALE_CHANNELS.forEach((channel: ScaleChannel) => {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      return;\n    }\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n\n    const specifiedScale = model.specifiedScales[channel];\n    const fieldDef = model.fieldDef(channel);\n\n    // Read if there is a specified width/height\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    let sizeSpecified = sizeType ? !!model.component.layoutSize.get(sizeType) : undefined;\n\n    const scaleType = mergedScaleCmpt.get('type');\n\n    // if autosize is fit, size cannot be data driven\n    const rangeStep = util.contains(['point', 'band'], scaleType) || !!specifiedScale.rangeStep;\n    if (sizeType && model.fit && !sizeSpecified && rangeStep) {\n      log.warn(log.message.CANNOT_FIX_RANGE_STEP_WITH_FIT);\n      sizeSpecified = true;\n    }\n\n    const xyRangeSteps = getXYRangeStep(model);\n\n    const rangeWithExplicit = parseRangeForChannel(\n      channel,\n      scaleType,\n      fieldDef.type,\n      specifiedScale,\n      model.config,\n      localScaleCmpt.get('zero'),\n      model.mark,\n      sizeSpecified,\n      model.getName(sizeType),\n      xyRangeSteps\n    );\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getXYRangeStep(model: UnitModel) {\n  const xyRangeSteps: number[] = [];\n\n  const xScale = model.getScaleComponent('x');\n  const xRange = xScale && xScale.get('range');\n  if (xRange && isVgRangeStep(xRange) && isNumber(xRange.step)) {\n    xyRangeSteps.push(xRange.step);\n  }\n\n  const yScale = model.getScaleComponent('y');\n  const yRange = yScale && yScale.get('range');\n  if (yRange && isVgRangeStep(yRange) && isNumber(yRange.step)) {\n    xyRangeSteps.push(yRange.step);\n  }\n\n  return xyRangeSteps;\n}\n\n/**\n * Return mixins that includes one of the range properties (range, rangeStep, scheme).\n */\nexport function parseRangeForChannel(\n  channel: Channel,\n  scaleType: ScaleType,\n  type: Type,\n  specifiedScale: Scale,\n  config: Config,\n  zero: boolean,\n  mark: Mark,\n  sizeSpecified: boolean,\n  sizeSignal: string,\n  xyRangeSteps: number[]\n): Explicit<VgRange> {\n  const noRangeStep = sizeSpecified || specifiedScale.rangeStep === null;\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return makeExplicit(specifiedScale[property]);\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n          case 'rangeStep':\n            const rangeStep = specifiedScale[property];\n            if (rangeStep !== null) {\n              if (!sizeSpecified) {\n                return makeExplicit({step: rangeStep});\n              } else {\n                // If top-level size is specified, we ignore specified rangeStep.\n                log.warn(log.message.rangeStepDropped(channel));\n              }\n            }\n        }\n      }\n    }\n  }\n  return makeImplicit(\n    defaultRange(\n      channel,\n      scaleType,\n      type,\n      config,\n      zero,\n      mark,\n      sizeSignal,\n      xyRangeSteps,\n      noRangeStep,\n      specifiedScale.domain\n    )\n  );\n}\n\nfunction parseScheme(scheme: Scheme) {\n  if (isExtendedScheme(scheme)) {\n    const r: VgScheme = {scheme: scheme.name};\n    if (scheme.count) {\n      r.count = scheme.count;\n    }\n    if (scheme.extent) {\n      r.extent = scheme.extent;\n    }\n    return r;\n  }\n  return {scheme: scheme};\n}\n\nexport function defaultRange(\n  channel: Channel,\n  scaleType: ScaleType,\n  type: Type,\n  config: Config,\n  zero: boolean,\n  mark: Mark,\n  sizeSignal: string,\n  xyRangeSteps: number[],\n  noRangeStep: boolean,\n  domain: Domain\n): VgRange {\n  switch (channel) {\n    case X:\n    case Y:\n      if (util.contains(['point', 'band'], scaleType) && !noRangeStep) {\n        if (channel === X && mark === 'text') {\n          if (config.scale.textXRangeStep) {\n            return {step: config.scale.textXRangeStep};\n          }\n        } else {\n          if (config.scale.rangeStep) {\n            return {step: config.scale.rangeStep};\n          }\n        }\n      }\n\n      // If range step is null, use zero to width or height.\n      // Note that these range signals are temporary\n      // as they can be merged and renamed.\n      // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n      // We will later replace these temporary names with\n      // the final name in assembleScaleRange()\n\n      if (channel === Y && hasContinuousDomain(scaleType)) {\n        // For y continuous scale, we have to start from the height as the bottom part has the max value.\n        return [{signal: sizeSignal}, 0];\n      } else {\n        return [0, {signal: sizeSignal}];\n      }\n    case SIZE:\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, xyRangeSteps, config);\n      if (isContinuousToDiscrete(scaleType)) {\n        return interpolateRange(\n          rangeMin,\n          rangeMax,\n          defaultContinuousToDiscreteCount(scaleType, config, domain, channel)\n        );\n      } else {\n        return [rangeMin, rangeMax];\n      }\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else if (isContinuousToDiscrete(scaleType)) {\n        const count = defaultContinuousToDiscreteCount(scaleType, config, domain, channel);\n        if (config.range && isVgScheme(config.range.ordinal)) {\n          return {\n            ...config.range.ordinal,\n            count\n          };\n        } else {\n          return {scheme: 'blues', count};\n        }\n      } else if (isContinuousToContinuous(scaleType)) {\n        // Manually set colors for now. We will revise this after https://github.com/vega/vega/issues/1369\n        return ['#f7fbff', '#0e427f'];\n      } else {\n        return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n      }\n    case OPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nexport function defaultContinuousToDiscreteCount(\n  scaleType: 'quantile' | 'quantize' | 'threshold',\n  config: Config,\n  domain: Domain,\n  channel: Channel\n) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin: number, rangeMax: number, cardinality: number) {\n  const ranges: number[] = [];\n  const step = (rangeMax - rangeMin) / (cardinality - 1);\n  for (let i = 0; i < cardinality; i++) {\n    ranges.push(rangeMin + i * step);\n  }\n  return ranges;\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nfunction sizeRangeMax(mark: Mark, xyRangeSteps: number[], config: Config) {\n  const scaleConfig = config.scale;\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      return minXYRangeStep(xyRangeSteps, config.scale) - 1;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      // FIXME this case totally should be refactored\n      const pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);\n      return (pointStep - 2) * (pointStep - 2);\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYRangeStep(xyRangeSteps: number[], scaleConfig: ScaleConfig): number {\n  if (xyRangeSteps.length > 0) {\n    return Math.min.apply(null, xyRangeSteps);\n  }\n  if (scaleConfig.rangeStep) {\n    return scaleConfig.rangeStep;\n  }\n  return 21; // FIXME: re-evaluate the default value here.\n}\n"]}