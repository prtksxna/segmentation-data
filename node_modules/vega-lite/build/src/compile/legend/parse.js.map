{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/legend/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {COLOR, FILL, NonPositionScaleChannel, OPACITY, SHAPE, SIZE, STROKE} from '../../channel';\nimport {FieldDef, isFieldDef, title as fieldDefTitle} from '../../fielddef';\nimport {Legend, LEGEND_PROPERTIES, VG_LEGEND_PROPERTIES} from '../../legend';\nimport {GEOJSON} from '../../type';\nimport {deleteNestedProperty, getFirstDefined, keys} from '../../util';\nimport {guideEncodeEntry, mergeTitleComponent, numberFormat} from '../common';\nimport {isUnitModel, Model} from '../model';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LegendComponent, LegendComponentIndex} from './component';\nimport * as encode from './encode';\nimport * as properties from './properties';\n\nexport function parseLegend(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.legends = parseUnitLegend(model);\n  } else {\n    model.component.legends = parseNonUnitLegend(model);\n  }\n}\n\nfunction parseUnitLegend(model: UnitModel): LegendComponentIndex {\n  const {encoding} = model;\n  return [COLOR, FILL, STROKE, SIZE, SHAPE, OPACITY].reduce((legendComponent, channel) => {\n    const def = encoding[channel];\n    if (\n      model.legend(channel) &&\n      model.getScaleComponent(channel) &&\n      !(isFieldDef(def) && (channel === SHAPE && def.type === GEOJSON))\n    ) {\n      legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: NonPositionScaleChannel): VgLegend {\n  // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels\n  switch (channel) {\n    case COLOR:\n      const scale = model.scaleName(COLOR);\n      return model.markDef.filled ? {fill: scale} : {stroke: scale};\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n      return {[channel]: model.scaleName(channel)};\n  }\n}\n\nfunction isExplicit<T extends string | number | object | boolean>(\n  value: T,\n  property: keyof VgLegend,\n  legend: Legend,\n  fieldDef: FieldDef<string>\n) {\n  switch (property) {\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend.values;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef.title) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === legend[property];\n}\n\nexport function parseLegendForChannel(model: UnitModel, channel: NonPositionScaleChannel): LegendComponent {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n\n  for (const property of LEGEND_PROPERTIES) {\n    const value = getProperty(property, legend, channel, model);\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, fieldDef);\n      if (explicit || model.config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = legend.encoding || {};\n  const legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient'].reduce(\n    (e: LegendEncode, part) => {\n      const legendEncodingPart = guideEncodeEntry(legendEncoding[part] || {}, model);\n      const value = encode[part]\n        ? encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt) // apply rule\n        : legendEncodingPart; // no rule -- just default values\n      if (value !== undefined && keys(value).length > 0) {\n        e[part] = {update: value};\n      }\n      return e;\n    },\n    {} as LegendEncode\n  );\n\n  if (keys(legendEncode).length > 0) {\n    legendCmpt.set('encode', legendEncode, !!legend.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction getProperty(\n  property: keyof (VgLegend),\n  specifiedLegend: Legend,\n  channel: NonPositionScaleChannel,\n  model: UnitModel\n) {\n  const fieldDef = model.fieldDef(channel);\n\n  switch (property) {\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      return numberFormat(fieldDef, specifiedLegend.format, model.config);\n    case 'title':\n      return fieldDefTitle(fieldDef, model.config, {allowDisabling: true}) || undefined;\n\n    // TODO: enable when https://github.com/vega/vega/issues/1351 is fixed\n    // case 'clipHeight':\n    //   return getFirstDefined(specifiedLegend.clipHeight, properties.clipHeight(model.getScaleComponent(channel).get('type')));\n    case 'labelOverlap':\n      return getFirstDefined(\n        specifiedLegend.labelOverlap,\n        properties.labelOverlap(model.getScaleComponent(channel).get('type'))\n      );\n    case 'values':\n      return properties.values(specifiedLegend, fieldDef);\n  }\n\n  // Otherwise, return specified property.\n  return specifiedLegend[property];\n}\n\nfunction parseNonUnitLegend(model: Model) {\n  const {legends, resolve} = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    });\n  }\n\n  keys(legends).forEach((channel: NonPositionScaleChannel) => {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  });\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend: LegendComponent, childLegend: LegendComponent): LegendComponent {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of VG_LEGEND_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<VgLegend, any>(\n      mergedLegend.getWithExplicit(prop),\n      childLegend.getWithExplicit(prop),\n      prop,\n      'legend',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>): any => {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker<VgLegend, any>(v1, v2, prop, 'legend');\n      }\n    );\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if (((mergedLegend.implicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (((mergedLegend.explicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n"]}