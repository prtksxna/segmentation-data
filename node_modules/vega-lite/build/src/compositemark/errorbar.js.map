{"version":3,"file":"errorbar.js","sourceRoot":"","sources":["../../../src/compositemark/errorbar.ts"],"names":[],"mappings":"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","sourcesContent":["import {Channel} from '../channel';\nimport {Config} from '../config';\nimport {Data} from '../data';\nimport {Encoding, extractTransformsFromEncoding} from '../encoding';\nimport {Field, isContinuous, isFieldDef, PositionFieldDef} from '../fielddef';\nimport * as log from '../log';\nimport {isMarkDef, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {TitleParams} from '../title';\nimport {AggregatedFieldDef, CalculateTransform, Transform} from '../transform';\nimport {Flag, keys} from '../util';\nimport {Orient} from '../vega.schema';\nimport {\n  compositeMarkContinuousAxis,\n  compositeMarkOrient,\n  filterUnsupportedChannels,\n  GenericCompositeMarkDef,\n  makeCompositeAggregatePartFactory,\n  PartsMixins\n} from './common';\nimport {ErrorBand, ErrorBandDef} from './errorband';\n\nexport const ERRORBAR: 'errorbar' = 'errorbar';\nexport type ErrorBar = typeof ERRORBAR;\n\nexport type ErrorBarExtent = 'ci' | 'iqr' | 'stderr' | 'stdev';\nexport type ErrorBarCenter = 'mean' | 'median';\n\nexport type ErrorBarPart = 'ticks' | 'rule';\n\nconst ERRORBAR_PART_INDEX: Flag<ErrorBarPart> = {\n  ticks: 1,\n  rule: 1\n};\n\nexport const ERRORBAR_PARTS = keys(ERRORBAR_PART_INDEX);\n\nexport type ErrorBarPartsMixins = PartsMixins<ErrorBarPart>;\n\nexport interface ErrorBarConfig extends ErrorBarPartsMixins {\n  /**\n   * The center of the errorbar. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hide\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the rule. Available options include:\n   * - `\"ci\"`: Extend the rule to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of rule are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of rule are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the rule to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n}\n\nexport type ErrorBarDef = GenericCompositeMarkDef<ErrorBar> &\n  ErrorBarConfig & {\n    /**\n     * Orientation of the error bar.  This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orient;\n  };\n\nexport interface ErrorBarConfigMixins {\n  /**\n   * ErrorBar Config\n   */\n  errorbar?: ErrorBarConfig;\n}\n\nexport function normalizeErrorBar(\n  spec: GenericUnitSpec<Encoding<string>, ErrorBar | ErrorBarDef>,\n  config: Config\n): NormalizedLayerSpec {\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    markDef,\n    outerSpec\n  } = errorBarParams(spec, ERRORBAR, config);\n\n  const makeErrorBarPart = makeCompositeAggregatePartFactory<ErrorBarPartsMixins>(\n    markDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorbar\n  );\n\n  const tick: MarkDef = {type: 'tick', orient: ticksOrient};\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      ...makeErrorBarPart('ticks', tick, 'lower'),\n      ...makeErrorBarPart('ticks', tick, 'upper'),\n      ...makeErrorBarPart('rule', 'rule', 'lower', 'upper')\n    ]\n  };\n}\n\nfunction errorBarOrientAndRange(\n  spec: GenericUnitSpec<Encoding<Field>, ErrorBar | ErrorBand | ErrorBarDef | ErrorBandDef>,\n  compositeMark: ErrorBar | ErrorBand\n): {\n  orient: Orient;\n  isRangedErrorBar: boolean;\n} {\n  const {encoding} = spec;\n  if (isFieldDef(encoding.x2) && isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // having x and x2\n    if (isFieldDef(encoding.y2) && isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // having both x, x2 and y, y2\n      throw new Error('Cannot have both x2 and y2 with both are quantiative');\n    } else {\n      // having x, x2 but not y, y2\n      return {orient: 'horizontal', isRangedErrorBar: true};\n    }\n  } else if (isFieldDef(encoding.y2) && isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // having y, y2 but not x, x2\n    return {orient: 'vertical', isRangedErrorBar: true};\n  }\n\n  return {\n    orient: compositeMarkOrient(spec, compositeMark),\n    isRangedErrorBar: false\n  };\n}\n\nexport const errorBarSupportedChannels: Channel[] = ['x', 'y', 'x2', 'y2', 'color', 'detail', 'opacity'];\n\nexport function errorBarParams<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  spec: GenericUnitSpec<Encoding<string>, M | MD>,\n  compositeMark: M,\n  config: Config\n): {\n  transform: Transform[];\n  groupby: string[];\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxis: 'x' | 'y';\n  encodingWithoutContinuousAxis: Encoding<string>;\n  ticksOrient: Orient;\n  markDef: MD;\n  outerSpec: {\n    data?: Data;\n    title?: string | TitleParams;\n    name?: string;\n    description?: string;\n    transform?: Transform[];\n    width?: number;\n    height?: number;\n  };\n} {\n  spec = filterUnsupportedChannels<M, MD>(spec, errorBarSupportedChannels, compositeMark);\n\n  // TODO: use selection\n  const {mark, encoding, selection, projection: _p, ...outerSpec} = spec;\n  const markDef: MD = isMarkDef(mark) ? mark : ({type: mark} as MD);\n\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (selection) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  const {orient, isRangedErrorBar} = errorBarOrientAndRange(spec, compositeMark);\n  const {continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxis} = compositeMarkContinuousAxis(\n    spec,\n    orient,\n    compositeMark\n  );\n  const {errorBarSpecificAggregate, postAggregateCalculates} = errorBarAggregationAndCalculation(\n    markDef,\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    isRangedErrorBar,\n    compositeMark,\n    config\n  );\n\n  const {\n    [continuousAxis]: oldContinuousAxisChannelDef,\n    [continuousAxis + '2']: oldContinuousAxisChannelDef2,\n    ...oldEncodingWithoutContinuousAxis\n  } = encoding;\n  const {\n    bins,\n    timeUnits,\n    aggregate: oldAggregate,\n    groupby: oldGroupBy,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n\n  const aggregate: AggregatedFieldDef[] = [...oldAggregate, ...errorBarSpecificAggregate];\n  const groupby: string[] = isRangedErrorBar ? [] : oldGroupBy;\n\n  return {\n    transform: [\n      ...bins,\n      ...timeUnits,\n      ...(!aggregate.length ? [] : [{aggregate, groupby}]),\n      ...postAggregateCalculates\n    ],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef,\n    outerSpec\n  };\n}\n\nfunction errorBarAggregationAndCalculation<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  markDef: MD,\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  continuousAxisChannelDef2: PositionFieldDef<string>,\n  isRangedErrorBar: boolean,\n  compositeMark: M,\n  config: Config\n): {\n  postAggregateCalculates: CalculateTransform[];\n  errorBarSpecificAggregate: AggregatedFieldDef[];\n} {\n  let errorBarSpecificAggregate: AggregatedFieldDef[] = [];\n  let postAggregateCalculates: CalculateTransform[] = [];\n  const continuousFieldName: string = continuousAxisChannelDef.field;\n\n  if (isRangedErrorBar) {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    postAggregateCalculates = [\n      {\n        calculate: `datum.${continuousFieldName}`,\n        as: `lower_` + continuousFieldName\n      },\n      {\n        calculate: `datum.${continuousAxisChannelDef2.field}`,\n        as: `upper_` + continuousFieldName\n      }\n    ];\n  } else {\n    const center: ErrorBarCenter = markDef.center\n      ? markDef.center\n      : markDef.extent\n        ? markDef.extent === 'iqr'\n          ? 'median'\n          : 'mean'\n        : config.errorbar.center;\n    const extent: ErrorBarExtent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if ((center === 'median') !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [\n        {\n          op: extent,\n          field: continuousFieldName,\n          as: 'extent_' + continuousFieldName\n        },\n        {\n          op: center,\n          field: continuousFieldName,\n          as: 'center_' + continuousFieldName\n        }\n      ];\n\n      postAggregateCalculates = [\n        {\n          calculate: `datum.center_${continuousFieldName} + datum.extent_${continuousFieldName}`,\n          as: 'upper_' + continuousFieldName\n        },\n        {\n          calculate: `datum.center_${continuousFieldName} - datum.extent_${continuousFieldName}`,\n          as: 'lower_' + continuousFieldName\n        }\n      ];\n    } else {\n      if (markDef.center && markDef.extent) {\n        log.warn(log.message.errorBarCenterIsNotNeeded(markDef.extent, compositeMark));\n      }\n\n      errorBarSpecificAggregate = [\n        {\n          op: extent === 'ci' ? 'ci0' : 'q1',\n          field: continuousFieldName,\n          as: 'lower_' + continuousFieldName\n        },\n        {\n          op: extent === 'ci' ? 'ci1' : 'q3',\n          field: continuousFieldName,\n          as: 'upper_' + continuousFieldName\n        }\n      ];\n    }\n  }\n  return {postAggregateCalculates, errorBarSpecificAggregate};\n}\n"]}