{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/compositemark/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {isBoolean, isString} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from '.';\nimport {Channel} from '../channel';\nimport {Encoding, reduce} from '../encoding';\nimport {Field, FieldDef, isContinuous, isFieldDef, PositionFieldDef} from '../fielddef';\nimport * as log from '../log';\nimport {ColorMixins, GenericMarkDef, isMarkDef, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {Orient} from '../vega.schema';\n\nexport type PartsMixins<P extends string> = Partial<Record<P, boolean | MarkConfig>>;\n\nexport type GenericCompositeMarkDef<T> = GenericMarkDef<T> &\n  ColorMixins & {\n    /**\n     * Opacity of the marks.\n     */\n    opacity?: number;\n  };\n\nexport function makeCompositeAggregatePartFactory<P extends PartsMixins<any>>(\n  compositeMarkDef: GenericCompositeMarkDef<any> & P,\n  continuousAxis: 'x' | 'y',\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  sharedEncoding: Encoding<string>,\n  compositeMarkConfig: P\n) {\n  const {scale, axis} = continuousAxisChannelDef;\n\n  return (\n    partName: keyof P,\n    mark: Mark | MarkDef,\n    positionPrefix: string,\n    endPositionPrefix: string = undefined,\n    extraEncoding: Encoding<string> = {}\n  ) => {\n    const title =\n      axis && axis.title !== undefined\n        ? undefined\n        : continuousAxisChannelDef.title !== undefined\n          ? continuousAxisChannelDef.title\n          : continuousAxisChannelDef.field;\n\n    return partLayerMixins<P>(compositeMarkDef, partName, compositeMarkConfig, {\n      mark, // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: positionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type,\n          ...(title ? {title} : {}),\n          ...(scale ? {scale} : {}),\n          ...(axis ? {axis} : {})\n        },\n        ...(isString(endPositionPrefix)\n          ? {\n              [continuousAxis + '2']: {\n                field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n                type: continuousAxisChannelDef.type\n              }\n            }\n          : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\n\nexport function partLayerMixins<P extends PartsMixins<any>>(\n  markDef: GenericCompositeMarkDef<any> & P,\n  part: keyof P,\n  compositeMarkConfig: P,\n  partBaseSpec: NormalizedUnitSpec\n): NormalizedUnitSpec[] {\n  const {color, opacity} = markDef;\n\n  const mark = markDef.type;\n\n  if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n    return [\n      {\n        ...partBaseSpec,\n        mark: {\n          ...(compositeMarkConfig[part] as MarkConfig),\n          ...(color ? {color} : {}),\n          ...(opacity ? {opacity} : {}),\n          ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}),\n          style: `${mark}-${part}`,\n          ...(isBoolean(markDef[part]) ? {} : (markDef[part] as MarkConfig))\n        }\n      }\n    ];\n  }\n  return [];\n}\n\nexport function compositeMarkContinuousAxis<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  orient: Orient,\n  compositeMark: M\n) {\n  const {encoding} = spec;\n\n  let continuousAxisChannelDef: PositionFieldDef<string>;\n  let continuousAxisChannelDef2: PositionFieldDef<string>;\n  let continuousAxis: 'x' | 'y';\n\n  if (orient === 'vertical') {\n    continuousAxis = 'y';\n    continuousAxisChannelDef = encoding.y as FieldDef<string>; // Safe to cast because if y is not continuous fielddef, the orient would not be vertical.\n    continuousAxisChannelDef2 = encoding.y2 ? (encoding.y2 as FieldDef<string>) : undefined;\n  } else {\n    continuousAxis = 'x';\n    continuousAxisChannelDef = encoding.x as FieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n    continuousAxisChannelDef2 = encoding.x2 ? (encoding.x2 as FieldDef<string>) : undefined;\n  }\n\n  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    continuousAxisChannelDef = continuousAxisWithoutAggregate;\n  }\n\n  if (continuousAxisChannelDef2 && continuousAxisChannelDef2.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate2} = continuousAxisChannelDef2;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    continuousAxisChannelDef2 = continuousAxisWithoutAggregate2;\n  }\n\n  return {\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    continuousAxis\n  };\n}\n\nexport function compositeMarkOrient<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<Field>, CompositeMark | CompositeMarkDef>,\n  compositeMark: M\n): Orient {\n  const {mark, encoding} = spec;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        }\n\n        // default orientation = vertical\n        return 'vertical';\n      }\n    }\n\n    // x is continuous but y is not\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}\n\nexport function filterUnsupportedChannels<M extends CompositeMark, MD extends GenericCompositeMarkDef<M>>(\n  spec: GenericUnitSpec<Encoding<string>, M | MD>,\n  supportedChannels: Channel[],\n  compositeMark: M\n): GenericUnitSpec<Encoding<string>, M | MD> {\n  return {\n    ...spec,\n    encoding: reduce(\n      spec.encoding,\n      (newEncoding, fieldDef, channel) => {\n        if (supportedChannels.indexOf(channel) > -1) {\n          newEncoding[channel] = fieldDef;\n        } else {\n          log.warn(log.message.incompatibleChannel(channel, compositeMark));\n        }\n        return newEncoding;\n      },\n      {}\n    )\n  };\n}\n"]}