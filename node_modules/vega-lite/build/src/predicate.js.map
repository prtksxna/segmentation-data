{"version":3,"file":"predicate.js","sourceRoot":"","sources":["../../src/predicate.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray, isString} from 'vega-util';\nimport {DataFlowNode} from './compile/data/dataflow';\nimport {Model} from './compile/model';\nimport {selectionPredicate} from './compile/selection/selection';\nimport {DateTime} from './datetime';\nimport {valueExpr, vgField} from './fielddef';\nimport {LogicalOperand} from './logical';\nimport {fieldExpr as timeUnitFieldExpr, normalizeTimeUnit, TimeUnit} from './timeunit';\nimport {logicalExpr} from './util';\n\nexport type Predicate =\n  // a) FieldPredicate (but we don't type FieldFilter here so the schema has no nesting\n  // and thus the documentation shows all of the types clearly)\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldValidPredicate\n  // b) Selection Predicate\n  | SelectionPredicate\n  // c) Vega Expression string\n  | string;\n\nexport type FieldPredicate =\n  | FieldEqualPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldValidPredicate;\n\nexport interface SelectionPredicate {\n  /**\n   * Filter using a selection name.\n   */\n  selection: LogicalOperand<string>;\n}\n\nexport function isSelectionPredicate(predicate: LogicalOperand<Predicate>): predicate is SelectionPredicate {\n  return predicate && predicate['selection'];\n}\n\nexport interface FieldPredicateBase {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered.\n   */\n  field: string;\n}\n\nexport interface FieldEqualPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime;\n}\n\nexport function isFieldEqualPredicate(predicate: any): predicate is FieldEqualPredicate {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\n\nexport interface FieldLTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than.\n   */\n  lt: string | number | DateTime;\n}\n\nexport function isFieldLTPredicate(predicate: any): predicate is FieldLTPredicate {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\n\nexport interface FieldLTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than or equals to.\n   */\n  lte: string | number | DateTime;\n}\n\nexport function isFieldLTEPredicate(predicate: any): predicate is FieldLTEPredicate {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\n\nexport interface FieldGTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than.\n   */\n  gt: string | number | DateTime;\n}\n\nexport function isFieldGTPredicate(predicate: any): predicate is FieldGTPredicate {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\n\nexport interface FieldGTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than or equals to.\n   */\n  gte: string | number | DateTime;\n}\n\nexport function isFieldGTEPredicate(predicate: any): predicate is FieldGTEPredicate {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\n\nexport interface FieldRangePredicate extends FieldPredicateBase {\n  /**\n   * An array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: (number | DateTime | null)[];\n}\n\nexport function isFieldRangePredicate(predicate: any): predicate is FieldRangePredicate {\n  if (predicate && predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface FieldOneOfPredicate extends FieldPredicateBase {\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: string[] | number[] | boolean[] | DateTime[];\n}\n\nexport interface FieldValidPredicate extends FieldPredicateBase {\n  /**\n   * If set to true the field's value has to be valid, meaning both not `null` and not [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).\n   */\n  valid: boolean;\n}\n\nexport function isFieldOneOfPredicate(predicate: any): predicate is FieldOneOfPredicate {\n  return (\n    predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  );\n}\n\nexport function isFieldValidPredicate(predicate: any): predicate is FieldValidPredicate {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\n\nexport function isFieldPredicate(\n  predicate: Predicate\n): predicate is\n  | FieldOneOfPredicate\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate {\n  return (\n    isFieldOneOfPredicate(predicate) ||\n    isFieldEqualPredicate(predicate) ||\n    isFieldRangePredicate(predicate) ||\n    isFieldLTPredicate(predicate) ||\n    isFieldGTPredicate(predicate) ||\n    isFieldLTEPredicate(predicate) ||\n    isFieldGTEPredicate(predicate)\n  );\n}\n\n/**\n * Converts a predicate into an expression.\n */\n// model is only used for selection filters.\nexport function expression(model: Model, filterOp: LogicalOperand<Predicate>, node?: DataFlowNode): string {\n  return logicalExpr(filterOp, (predicate: Predicate) => {\n    if (isString(predicate)) {\n      return predicate;\n    } else if (isSelectionPredicate(predicate)) {\n      return selectionPredicate(model, predicate.selection, node);\n    } else {\n      // Filter Object\n      return fieldFilterExpression(predicate);\n    }\n  });\n}\n\nfunction predicateValueExpr(v: number | string | boolean | DateTime, timeUnit: TimeUnit) {\n  return valueExpr(v, {timeUnit, time: true});\n}\n\nfunction predicateValuesExpr(vals: (number | string | boolean | DateTime)[], timeUnit: TimeUnit) {\n  return vals.map(v => predicateValueExpr(v, timeUnit));\n}\n\n// This method is used by Voyager.  Do not change its behavior without changing Voyager.\nexport function fieldFilterExpression(predicate: FieldPredicate, useInRange = true) {\n  const {field, timeUnit} = predicate;\n  const fieldExpr = timeUnit\n    ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n      // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n      // TODO: support utc\n      'time(' + timeUnitFieldExpr(timeUnit, field) + ')'\n    : vgField(predicate, {expr: 'datum'});\n\n  if (isFieldEqualPredicate(predicate)) {\n    return fieldExpr + '===' + predicateValueExpr(predicate.equal, timeUnit);\n  } else if (isFieldLTPredicate(predicate)) {\n    const upper = predicate.lt;\n    return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTPredicate(predicate)) {\n    const lower = predicate.gt;\n    return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldLTEPredicate(predicate)) {\n    const upper = predicate.lte;\n    return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTEPredicate(predicate)) {\n    const lower = predicate.gte;\n    return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n  } else if (isFieldValidPredicate(predicate)) {\n    return predicate.valid ? `${fieldExpr}!==null&&!isNaN(${fieldExpr})` : `${fieldExpr}===null||isNaN(${fieldExpr})`;\n  } else if (isFieldRangePredicate(predicate)) {\n    const lower = predicate.range[0];\n    const upper = predicate.range[1];\n\n    if (lower !== null && upper !== null && useInRange) {\n      return (\n        'inrange(' +\n        fieldExpr +\n        ', [' +\n        predicateValueExpr(lower, timeUnit) +\n        ', ' +\n        predicateValueExpr(upper, timeUnit) +\n        '])'\n      );\n    }\n\n    const exprs = [];\n    if (lower !== null) {\n      exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n    }\n    if (upper !== null) {\n      exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n\n  /* istanbul ignore next: it should never reach here */\n  throw new Error(`Invalid field predicate: ${JSON.stringify(predicate)}`);\n}\n\nexport function normalizePredicate(f: Predicate): Predicate {\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return {\n      ...f,\n      timeUnit: normalizeTimeUnit(f.timeUnit)\n    };\n  }\n  return f;\n}\n"]}