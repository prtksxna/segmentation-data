{"version":3,"file":"normalize.js","sourceRoot":"","sources":["../../src/normalize.ts"],"names":[],"mappings":"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","sourcesContent":["import {isObject} from 'vega-util';\nimport {COLUMN, ROW, X, X2, Y, Y2} from './channel';\nimport * as compositeMark from './compositemark';\nimport {Config} from './config';\nimport {channelHasField, Encoding, isRanged} from './encoding';\nimport {Field, RepeatRef} from './fielddef';\nimport * as log from './log';\nimport {\n  AnyMark,\n  AreaConfig,\n  isMarkDef,\n  isPathMark,\n  isPrimitiveMark,\n  LineConfig,\n  Mark,\n  MarkConfig,\n  MarkDef\n} from './mark';\nimport {Projection} from './projection';\nimport {\n  CompositeUnitSpec,\n  ExtendedLayerSpec,\n  FacetedCompositeUnitSpec,\n  GenericFacetSpec,\n  GenericHConcatSpec,\n  GenericRepeatSpec,\n  GenericSpec,\n  GenericUnitSpec,\n  GenericVConcatSpec,\n  isFacetSpec,\n  isHConcatSpec,\n  isLayerSpec,\n  isRepeatSpec,\n  isUnitSpec,\n  isVConcatSpec,\n  NormalizedConcatSpec,\n  NormalizedFacetSpec,\n  NormalizedLayerSpec,\n  NormalizedRepeatSpec,\n  NormalizedSpec,\n  NormalizedUnitSpec,\n  TopLevel,\n  TopLevelSpec\n} from './spec';\nimport {stack} from './stack';\nimport {duplicate, keys, omit, pick} from './util';\n\nexport function normalizeTopLevelSpec(\n  spec: TopLevelSpec | GenericSpec<CompositeUnitSpec, ExtendedLayerSpec> | FacetedCompositeUnitSpec,\n  config: Config\n): TopLevel<NormalizedSpec> {\n  return normalize(spec, config);\n}\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\nfunction normalize(\n  spec: GenericSpec<CompositeUnitSpec, ExtendedLayerSpec> | FacetedCompositeUnitSpec,\n  config: Config\n): NormalizedSpec {\n  if (isFacetSpec(spec)) {\n    return normalizeFacet(spec, config);\n  }\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec, config);\n  }\n  if (isRepeatSpec(spec)) {\n    return normalizeRepeat(spec, config);\n  }\n  if (isVConcatSpec(spec)) {\n    return normalizeVConcat(spec, config);\n  }\n  if (isHConcatSpec(spec)) {\n    return normalizeHConcat(spec, config);\n  }\n  if (isUnitSpec(spec)) {\n    const hasRow = channelHasField(spec.encoding, ROW);\n    const hasColumn = channelHasField(spec.encoding, COLUMN);\n\n    if (hasRow || hasColumn) {\n      return normalizeFacetedUnit(spec, config);\n    }\n    return normalizeNonFacetUnit(spec, config);\n  }\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nfunction normalizeFacet(\n  spec: GenericFacetSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedFacetSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n    spec: normalize(subspec, config) as any\n  };\n}\n\nfunction mergeEncoding(opt: {parentEncoding: Encoding<any>; encoding: Encoding<any>}): Encoding<any> {\n  const {parentEncoding, encoding} = opt;\n  if (parentEncoding && encoding) {\n    const overriden = keys(parentEncoding).reduce((o, key) => {\n      if (encoding[key]) {\n        o.push(key);\n      }\n      return o;\n    }, []);\n\n    if (overriden.length > 0) {\n      log.warn(log.message.encodingOverridden(overriden));\n    }\n  }\n\n  const merged = {\n    ...(parentEncoding || {}),\n    ...(encoding || {})\n  };\n  return keys(merged).length > 0 ? merged : undefined;\n}\n\nfunction mergeProjection(opt: {parentProjection: Projection; projection: Projection}) {\n  const {parentProjection, projection} = opt;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({parentProjection, projection}));\n  }\n  return projection || parentProjection;\n}\n\nfunction normalizeLayer(\n  spec: ExtendedLayerSpec,\n  config: Config,\n  parentEncoding?: Encoding<string | RepeatRef>,\n  parentProjection?: Projection\n): NormalizedLayerSpec {\n  const {layer, encoding, projection, ...rest} = spec;\n  const mergedEncoding = mergeEncoding({parentEncoding, encoding});\n  const mergedProjection = mergeProjection({parentProjection, projection});\n  return {\n    ...rest,\n    layer: layer.map(subspec => {\n      if (isLayerSpec(subspec)) {\n        return normalizeLayer(subspec, config, mergedEncoding, mergedProjection);\n      }\n      return normalizeNonFacetUnit(subspec, config, mergedEncoding, mergedProjection);\n    })\n  };\n}\n\nfunction normalizeRepeat(\n  spec: GenericRepeatSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedRepeatSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    spec: normalize(subspec, config)\n  };\n}\n\nfunction normalizeVConcat(\n  spec: GenericVConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedConcatSpec {\n  const {vconcat: vconcat, ...rest} = spec;\n  return {\n    ...rest,\n    vconcat: vconcat.map(subspec => normalize(subspec, config))\n  };\n}\n\nfunction normalizeHConcat(\n  spec: GenericHConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedConcatSpec {\n  const {hconcat: hconcat, ...rest} = spec;\n  return {\n    ...rest,\n    hconcat: hconcat.map(subspec => normalize(subspec, config))\n  };\n}\n\nfunction normalizeFacetedUnit(spec: FacetedCompositeUnitSpec, config: Config): NormalizedFacetSpec {\n  // New encoding in the inside spec should not contain row / column\n  // as row/column should be moved to facet\n  const {row: row, column: column, ...encoding} = spec.encoding;\n\n  // Mark and encoding should be moved into the inner spec\n  const {mark, width, projection, height, selection, encoding: _, ...outerSpec} = spec;\n\n  return {\n    ...outerSpec,\n    facet: {\n      ...(row ? {row} : {}),\n      ...(column ? {column} : {})\n    },\n    spec: normalizeNonFacetUnit(\n      {\n        ...(projection ? {projection} : {}),\n        mark,\n        ...(width ? {width} : {}),\n        ...(height ? {height} : {}),\n        encoding,\n        ...(selection ? {selection} : {})\n      },\n      config\n    )\n  };\n}\n\nfunction isNonFacetUnitSpecWithPrimitiveMark(\n  spec: GenericUnitSpec<Encoding<Field>, AnyMark>\n): spec is GenericUnitSpec<Encoding<Field>, Mark> {\n  return isPrimitiveMark(spec.mark);\n}\n\nfunction getPointOverlay(markDef: MarkDef, markConfig: LineConfig, encoding: Encoding<Field>): MarkConfig {\n  if (markDef.point === 'transparent') {\n    return {opacity: 0};\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return null;\n  }\n}\n\nfunction getLineOverlay(markDef: MarkDef, markConfig: AreaConfig): MarkConfig {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return null;\n  }\n}\n\nfunction normalizeNonFacetUnit(\n  spec: GenericUnitSpec<Encoding<Field>, AnyMark>,\n  config: Config,\n  parentEncoding?: Encoding<string | RepeatRef>,\n  parentProjection?: Projection\n): NormalizedUnitSpec | NormalizedLayerSpec {\n  const {encoding, projection} = spec;\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n\n  // merge parent encoding / projection first\n  if (parentEncoding || parentProjection) {\n    const mergedProjection = mergeProjection({parentProjection, projection});\n    const mergedEncoding = mergeEncoding({parentEncoding, encoding});\n    return normalizeNonFacetUnit(\n      {\n        ...spec,\n        ...(mergedProjection ? {projection: mergedProjection} : {}),\n        ...(mergedEncoding ? {encoding: mergedEncoding} : {})\n      },\n      config\n    );\n  }\n\n  if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {\n    // TODO: thoroughly test\n    if (isRanged(encoding)) {\n      return normalizeRangedUnit(spec);\n    }\n\n    if (mark === 'line' && (encoding.x2 || encoding.y2)) {\n      log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n\n      return normalizeNonFacetUnit(\n        {\n          mark: 'rule',\n          ...spec\n        },\n        config,\n        parentEncoding,\n        parentProjection\n      );\n    }\n\n    if (isPathMark(mark)) {\n      return normalizePathOverlay(spec, config);\n    }\n\n    return spec; // Nothing to normalize\n  } else {\n    return compositeMark.normalize(spec, config);\n  }\n}\n\nfunction normalizeRangedUnit(spec: NormalizedUnitSpec) {\n  const hasX = channelHasField(spec.encoding, X);\n  const hasY = channelHasField(spec.encoding, Y);\n  const hasX2 = channelHasField(spec.encoding, X2);\n  const hasY2 = channelHasField(spec.encoding, Y2);\n  if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n    const normalizedSpec = duplicate(spec);\n    if (hasX2 && !hasX) {\n      normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n      delete normalizedSpec.encoding.x2;\n    }\n    if (hasY2 && !hasY) {\n      normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n      delete normalizedSpec.encoding.y2;\n    }\n\n    return normalizedSpec;\n  }\n  return spec;\n}\n\nfunction dropLineAndPoint(markDef: MarkDef): MarkDef | Mark {\n  const {point: _point, line: _line, ...mark} = markDef;\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction normalizePathOverlay(spec: NormalizedUnitSpec, config: Config = {}): NormalizedLayerSpec | NormalizedUnitSpec {\n  // _ is used to denote a dropped property of the unit spec\n  // which should not be carried over to the layer spec\n  const {selection, projection, encoding, mark, ...outerSpec} = spec;\n  const markDef = isMarkDef(mark) ? mark : {type: mark};\n\n  const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n  const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n\n  if (!pointOverlay && !lineOverlay) {\n    return {\n      ...spec,\n      // Do not include point / line overlay in the normalize spec\n      mark: dropLineAndPoint(markDef)\n    };\n  }\n\n  const layer: NormalizedUnitSpec[] = [\n    {\n      ...(selection ? {selection} : {}),\n      // Do not include point / line overlay in the normalize spec\n      mark: dropLineAndPoint({\n        ...markDef,\n        // make area mark translucent by default\n        // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n        ...(markDef.type === 'area' ? {opacity: 0.7} : {})\n      }),\n      // drop shape from encoding as this might be used to trigger point overlay\n      encoding: omit(encoding, ['shape'])\n    }\n  ];\n\n  // FIXME: determine rules for applying selections.\n\n  // Need to copy stack config to overlayed layer\n  const stackProps = stack(markDef, encoding, config ? config.stack : undefined);\n\n  let overlayEncoding = encoding;\n  if (stackProps) {\n    const {fieldChannel: stackFieldChannel, offset} = stackProps;\n    overlayEncoding = {\n      ...encoding,\n      [stackFieldChannel]: {\n        ...encoding[stackFieldChannel],\n        ...(offset ? {stack: offset} : {})\n      }\n    };\n  }\n\n  if (lineOverlay) {\n    layer.push({\n      ...(projection ? {projection} : {}),\n      mark: {\n        type: 'line',\n        ...pick(markDef, ['clip', 'interpolate', 'tension']),\n        ...lineOverlay\n      },\n      encoding: overlayEncoding\n    });\n  }\n  if (pointOverlay) {\n    layer.push({\n      ...(projection ? {projection} : {}),\n      mark: {\n        type: 'point',\n        opacity: 1,\n        filled: true,\n        ...pick(markDef, ['clip']),\n        ...pointOverlay\n      },\n      encoding: overlayEncoding\n    });\n  }\n\n  return {\n    ...outerSpec,\n    layer\n  };\n}\n"]}